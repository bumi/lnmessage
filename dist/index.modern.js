import{BehaviorSubject as t,Subject as e,firstValueFrom as i}from"rxjs";import{map as s,skip as n,filter as r}from"rxjs/operators";import{Buffer as o}from"buffer";import h from"crypto-js";import a from"secp256k1";function c(){return c=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(t[s]=i[s])}return t},c.apply(this,arguments)}function d(t,e){return t<<e|t>>>32-e}const l=o.from("expand 32-byte k");class u{constructor(t,e){this.input=void 0,this.cachePos=void 0,this.buffer=void 0,this.output=void 0,this.input=new Uint32Array(16),this.input[0]=l.readUInt32LE(0),this.input[1]=l.readUInt32LE(4),this.input[2]=l.readUInt32LE(8),this.input[3]=l.readUInt32LE(12),this.input[4]=t.readUInt32LE(0),this.input[5]=t.readUInt32LE(4),this.input[6]=t.readUInt32LE(8),this.input[7]=t.readUInt32LE(12),this.input[8]=t.readUInt32LE(16),this.input[9]=t.readUInt32LE(20),this.input[10]=t.readUInt32LE(24),this.input[11]=t.readUInt32LE(28),this.input[12]=0,this.input[13]=e.readUInt32LE(0),this.input[14]=e.readUInt32LE(4),this.input[15]=e.readUInt32LE(8),this.cachePos=64,this.buffer=new Uint32Array(16),this.output=new o(64)}quarterRound(t,e,i,s){const n=this.buffer;n[t]+=n[e],n[s]=d(n[s]^n[t],16),n[i]+=n[s],n[e]=d(n[e]^n[i],12),n[t]+=n[e],n[s]=d(n[s]^n[t],8),n[i]+=n[s],n[e]=d(n[e]^n[i],7)}makeBlock(t,e){let i=-1;for(;++i<16;)this.buffer[i]=this.input[i];for(i=-1;++i<10;)this.quarterRound(0,4,8,12),this.quarterRound(1,5,9,13),this.quarterRound(2,6,10,14),this.quarterRound(3,7,11,15),this.quarterRound(0,5,10,15),this.quarterRound(1,6,11,12),this.quarterRound(2,7,8,13),this.quarterRound(3,4,9,14);for(i=-1;++i<16;)this.buffer[i]+=this.input[i],t.writeUInt32LE(this.buffer[i],e),e+=4;if(this.input[12]++,!this.input[12])throw new Error("counter is exausted")}getBytes(t){let e=0;const i=new o(t),s=64-this.cachePos;if(s){if(s>=t)return this.output.copy(i,0,this.cachePos,64),this.cachePos+=t,i;this.output.copy(i,0,this.cachePos,64),t-=s,e+=s,this.cachePos=64}for(;t>0;){if(t<=64)return this.makeBlock(this.output,0),this.output.copy(i,e,0,t),t<64&&(this.cachePos=t),i;this.makeBlock(i,e),t-=64,e+=64}throw new Error("something bad happended")}}class f{constructor(t){this.buffer=void 0,this.leftover=void 0,this.r=void 0,this.h=void 0,this.pad=void 0,this.finished=void 0,this.buffer=new o(16),this.leftover=0,this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.finished=0;let e,i=new Uint16Array(8);for(e=8;e--;)i[e]=t.readUInt16LE(2*e);for(this.r[0]=8191&i[0],this.r[1]=8191&(i[0]>>>13|i[1]<<3),this.r[2]=7939&(i[1]>>>10|i[2]<<6),this.r[3]=8191&(i[2]>>>7|i[3]<<9),this.r[4]=255&(i[3]>>>4|i[4]<<12),this.r[5]=i[4]>>>1&8190,this.r[6]=8191&(i[4]>>>14|i[5]<<2),this.r[7]=8065&(i[5]>>>11|i[6]<<5),this.r[8]=8191&(i[6]>>>8|i[7]<<8),this.r[9]=i[7]>>>5&127,e=8;e--;)this.h[e]=0,this.pad[e]=t.readUInt16LE(16+2*e);this.h[8]=0,this.h[9]=0,this.leftover=0,this.finished=0}blocks(t,e,i){const s=this.finished?0:2048;let n=new Uint16Array(8),r=new Uint32Array(10),o=0,h=0,a=0;for(;i>=16;){for(h=8;h--;)n[h]=t.readUInt16LE(2*h+e);for(this.h[0]+=8191&n[0],this.h[1]+=8191&(n[0]>>>13|n[1]<<3),this.h[2]+=8191&(n[1]>>>10|n[2]<<6),this.h[3]+=8191&(n[2]>>>7|n[3]<<9),this.h[4]+=8191&(n[3]>>>4|n[4]<<12),this.h[5]+=n[4]>>>1&8191,this.h[6]+=8191&(n[4]>>>14|n[5]<<2),this.h[7]+=8191&(n[5]>>>11|n[6]<<5),this.h[8]+=8191&(n[6]>>>8|n[7]<<8),this.h[9]+=n[7]>>>5|s,h=0,o=0;h<10;h++){for(r[h]=o,a=0;a<10;a++)r[h]+=(4294967295&this.h[a])*(a<=h?this.r[h-a]:5*this.r[h+10-a]),4===a&&(o=r[h]>>>13,r[h]&=8191);o+=r[h]>>>13,r[h]&=8191}for(o=(o<<2)+o,o+=r[0],r[0]=8191&o,o>>>=13,r[1]+=o,h=10;h--;)this.h[h]=r[h];e+=16,i-=16}}update(t){let e=t.length,i=0,s=0,n=0;if(this.leftover){for(i=16-this.leftover,i>e&&(i=e),s=i;s--;)this.buffer[this.leftover+s]=t[s+n];if(e-=i,n+=i,this.leftover+=i,this.leftover<16)return this;this.blocks(this.buffer,0,16),this.leftover=0}if(e>=16&&(i=-16&e,this.blocks(t,n,i),n+=i,e-=i),e){for(s=e;s--;)this.buffer[this.leftover+s]=t[s+n];this.leftover+=e}return this}finish(){let t=new o(16),e=new Uint16Array(10),i=0,s=0,n=0,r=0;if(this.leftover){for(r=this.leftover,this.buffer[r++]=1;r<16;r++)this.buffer[r]=0;this.finished=1,this.blocks(this.buffer,0,16)}for(i=this.h[1]>>>13,this.h[1]&=8191,r=2;r<10;r++)this.h[r]+=i,i=this.h[r]>>>13,this.h[r]&=8191;for(this.h[0]+=5*i,i=this.h[0]>>>13,this.h[0]&=8191,this.h[1]+=i,i=this.h[1]>>>13,this.h[1]&=8191,this.h[2]+=i,e[0]=this.h[0]+5,i=e[0]>>>13,e[0]&=8191,r=1;r<10;r++)e[r]=this.h[r]+i,i=e[r]>>>13,e[r]&=8191;for(e[9]-=8192,s=(e[9]>>>15)-1,r=10;r--;)e[r]&=s;for(s=~s,r=10;r--;)this.h[r]=this.h[r]&s|e[r];for(this.h[0]=this.h[0]|this.h[1]<<13,this.h[1]=this.h[1]>>3|this.h[2]<<10,this.h[2]=this.h[2]>>6|this.h[3]<<7,this.h[3]=this.h[3]>>9|this.h[4]<<4,this.h[4]=this.h[4]>>12|this.h[5]<<1|this.h[6]<<14,this.h[5]=this.h[6]>>2|this.h[7]<<11,this.h[6]=this.h[7]>>5|this.h[8]<<8,this.h[7]=this.h[8]>>8|this.h[9]<<5,n=(4294967295&this.h[0])+this.pad[0],this.h[0]=n,r=1;r<8;r++)n=(4294967295&this.h[r])+this.pad[r]+(n>>>16),this.h[r]=n;for(r=8;r--;)t.writeUInt16LE(this.h[r],2*r),this.pad[r]=0;for(r=10;r--;)this.h[r]=0,this.r[r]=0;return t}}class g{constructor(t,e,i=!1){this.alen=void 0,this.clen=void 0,this.chacha=void 0,this.poly=void 0,this.tag=void 0,this._decrypt=void 0,this._hasData=void 0,this.alen=0,this.clen=0,this.chacha=new u(t,e),this.poly=new f(this.chacha.getBytes(64)),this.tag=null,this._decrypt=i,this._hasData=!1}setAAD(t){if(this._hasData)throw new Error("Attempting to set AAD in unsupported state");this.alen=t.length,this.poly.update(t);const e=new o(p(this.alen));e.length&&(e.fill(0),this.poly.update(e))}update(t,e,i){"string"==typeof t&&(t=o.from(t,e));let s=this._update(t)||o.from("");return i?s.toString(i):s}final(t){let e=this._final()||o.from("");return t?e.toString(t):e}_update(t){this._hasData||(this._hasData=!0);const e=t.length;if(!e)return;this.clen+=e;const i=this.chacha.getBytes(e);let s=-1;for(;++s<e;)i[s]^=t[s];return this.poly.update(this._decrypt?t:i),i}_final(){if(this._decrypt&&!this.tag)throw new Error("Unsupported state or unable to authenticate data");const t=new o(p(this.clen));t.length&&(t.fill(0),this.poly.update(t));const e=new o(16);e.fill(0),e.writeUInt32LE(this.alen,0),e.writeUInt32LE(this.clen,8);const i=this.poly.update(e).finish();if(this._decrypt){if(function(t,e){let i=0;t.length!==e.length&&i++;const s=Math.min(t.length,e.length);let n=-1;for(;++n<s;)i+=t[n]^e[n];return i}(i,this.tag))throw new Error("Unsupported state or unable to authenticate data")}else this.tag=i;return i}getAuthTag(){return this._decrypt||null===this.tag?new o(""):this.tag}setAuthTag(t){if(!this._decrypt)throw new Error("Attempting to set auth tag in unsupported state");this.tag=t}}function p(t){const e=t%16;return e?16-e:0}function _(t,e){return o.from(a.ecdh(t,e))}function w(t,e){const i=h.HmacSHA256(h.enc.Hex.parse(e.toString("hex")),h.enc.Hex.parse(t.toString("hex")));return o.from(h.enc.Hex.stringify(i),"hex")}async function m(t){const e=await window.crypto.subtle.digest("SHA-256",t);return o.from(e)}function y(t,e,i=o.alloc(0),s=o.alloc(0)){const n=w(i,t),r=Math.ceil(e/n.byteLength);if(r>255)throw new Error("Output length exceeds maximum");const h=[o.alloc(0)];for(let t=1;t<=r;t++){const e=h[h.length-1],i=o.from([t]);h.push(w(n,o.concat([e,s,i])))}return o.concat(h.slice(1)).subarray(0,e)}function I(t,e=!0){return o.from(a.publicKeyCreate(t,e))}function B(t,e,i,s){const n=new g(t,e);n.setAAD(i);const r=n.update(s);n.final&&n.final();const h=n.getAuthTag();return o.concat([r,h])}function E(t,e,i,s){const n=new g(t,e,!0);if(n.setAAD(i),16===s.length)return n.setAuthTag(s),n.final();if(s.length>16){const t=s.subarray(s.length-16),e=s.subarray(0,s.length-16);n.setAuthTag(t);let i=n.update(e);const r=n.final();return i=o.concat([i,r]),i}}function b(){let t;do{const e=o.allocUnsafe(32);t=window.crypto.getRandomValues(e)}while(!v(t));return t.toString("hex")}function v(t){return a.privateKeyVerify("string"==typeof t?o.from(t,"hex"):t)}class R{constructor({ls:t,es:e}){this.protocolName=o.from("Noise_XK_secp256k1_ChaChaPoly_SHA256"),this.prologue=o.from("lightning"),this.ls=void 0,this.lpk=void 0,this.es=void 0,this.epk=void 0,this.rpk=void 0,this.repk=void 0,this.h=void 0,this.ck=void 0,this.rk=void 0,this.sk=void 0,this.sn=void 0,this.rn=void 0,this.tempK1=void 0,this.tempK2=void 0,this.tempK3=void 0,this.ls=t,this.lpk=I(t),this.es=e,this.epk=I(e)}async initiatorAct1(t){this.rpk=t,await this._initialize(this.rpk),this.h=await m(o.concat([this.h,this.epk]));const e=y(_(this.rpk,this.es),64,this.ck);this.ck=e.subarray(0,32),this.tempK1=e.subarray(32);const i=B(this.tempK1,o.alloc(12),this.h,o.alloc(0));return this.h=await m(o.concat([this.h,i])),o.concat([o.alloc(1),this.epk,i])}async initiatorAct2(t){if(50!==t.length)throw new Error("ACT2_READ_FAILED");const e=t.subarray(0,1)[0],i=t.subarray(1,34),s=t.subarray(34);if(this.repk=i,0!==e)throw new Error("ACT2_BAD_VERSION");this.h=await m(o.concat([this.h,this.repk]));const n=y(_(this.repk,this.es),64,this.ck);this.ck=n.subarray(0,32),this.tempK2=n.subarray(32),E(this.tempK2,o.alloc(12),this.h,s),this.h=await m(o.concat([this.h,s]))}async initiatorAct3(){const t=B(this.tempK2,o.from([0,0,0,0,1,0,0,0,0,0,0,0]),this.h,this.lpk);this.h=await m(o.concat([this.h,t]));const e=y(_(this.repk,this.ls),64,this.ck);this.ck=e.subarray(0,32),this.tempK3=e.subarray(32);const i=B(this.tempK3,o.alloc(12),this.h,o.alloc(0)),s=y(o.alloc(0),64,this.ck);return this.rk=s.subarray(32),this.sk=s.subarray(0,32),this.sn=o.alloc(12),this.rn=o.alloc(12),o.concat([o.alloc(1),t,i])}async receiveAct1(t){if(await this._initialize(this.lpk),50!==t.length)throw new Error("ACT1_READ_FAILED");const e=t.subarray(0,1)[0],i=t.subarray(1,34),s=t.subarray(34);if(this.repk=i,0!==e)throw new Error("ACT1_BAD_VERSION");this.h=await m(o.concat([this.h,i]));const n=y(_(i,this.ls),64,this.ck);this.ck=n.subarray(0,32),this.tempK1=n.subarray(32),E(this.tempK1,o.alloc(12),this.h,s),this.h=await m(o.concat([this.h,s]))}async recieveAct2(){this.h=await m(o.concat([this.h,this.epk]));const t=y(_(this.repk,this.es),64,this.ck);this.ck=t.subarray(0,32),this.tempK2=t.subarray(32);const e=B(this.tempK2,o.alloc(12),this.h,o.alloc(0));return this.h=await m(o.concat([this.h,e])),o.concat([o.alloc(1),this.epk,e])}async receiveAct3(t){if(66!==t.length)throw new Error("ACT3_READ_FAILED");const e=t.subarray(0,1)[0],i=t.subarray(1,50),s=t.subarray(50);if(0!==e)throw new Error("ACT3_BAD_VERSION");const n=E(this.tempK2,o.from("000000000100000000000000","hex"),this.h,i);this.rpk=n,this.h=await m(o.concat([this.h,i]));const r=y(_(this.rpk,this.es),64,this.ck);this.ck=r.subarray(0,32),this.tempK3=r.subarray(32),E(this.tempK3,o.alloc(12),this.h,s);const h=y(o.alloc(0),64,this.ck);this.rk=h.subarray(0,32),this.sk=h.subarray(32),this.rn=o.alloc(12),this.sn=o.alloc(12)}async encryptMessage(t){const e=o.alloc(2);e.writeUInt16BE(t.length,0);const i=B(this.sk,this.sn,o.alloc(0),e);this._incrementSendingNonce()>=1e3&&this._rotateSendingKeys();const s=B(this.sk,this.sn,o.alloc(0),t);return this._incrementSendingNonce()>=1e3&&this._rotateSendingKeys(),o.concat([i,s])}async decryptLength(t){const e=E(this.rk,this.rn,o.alloc(0),t);return this._incrementRecievingNonce()>=1e3&&this._rotateRecievingKeys(),e.readUInt16BE(0)}async decryptMessage(t){const e=E(this.rk,this.rn,o.alloc(0),t);return this._incrementRecievingNonce()>=1e3&&this._rotateRecievingKeys(),e}async _initialize(t){this.h=await m(o.from(this.protocolName)),this.ck=this.h,this.h=await m(o.concat([this.h,this.prologue])),this.h=await m(o.concat([this.h,t]))}_incrementSendingNonce(){const t=this.sn.readUInt16LE(4)+1;return this.sn.writeUInt16LE(t,4),t}_incrementRecievingNonce(){const t=this.rn.readUInt16LE(4)+1;return this.rn.writeUInt16LE(t,4),t}_rotateSendingKeys(){const t=y(this.sk,64,this.ck);this.sk=t.subarray(32),this.ck=t.subarray(0,32),this.sn=o.alloc(12)}_rotateRecievingKeys(){const t=y(this.rk,64,this.ck);this.rk=t.subarray(32),this.ck=t.subarray(0,32),this.rn=o.alloc(12)}}class U{static bigSizeBytes(t){return t<BigInt(253)?1:t<BigInt(65536)?3:t<BigInt(4294967296)?5:9}constructor(t){this._buffer=void 0,this._position=void 0,this._lastReadBytes=void 0,this._buffer=t,this._position=0,this._lastReadBytes=0}get position(){return this._position}set position(t){this._position=t}get eof(){return this._position===this._buffer.length}get buffer(){return this._buffer}get lastReadBytes(){return this._lastReadBytes}readUInt8(){return this._readStandard(this.readUInt8.name,1)}readUInt16LE(){return this._readStandard(this.readUInt16LE.name,2)}readUInt16BE(){return this._readStandard(this.readUInt16BE.name,2)}readUInt32LE(){return this._readStandard(this.readUInt32LE.name,4)}readUInt32BE(){return this._readStandard(this.readUInt32BE.name,4)}readUInt64BE(){return BigInt("0x"+this.readBytes(8).toString("hex"))}readUInt64LE(){return BigInt("0x"+this.readBytes(8).reverse().toString("hex"))}readVarUint(){const t=this.readUInt8();if(t<253)return this._lastReadBytes=1,BigInt(t);switch(t){case 253:return this._lastReadBytes=3,BigInt(this.readUInt16LE());case 254:return this._lastReadBytes=5,BigInt(this.readUInt32LE());case 255:return this._lastReadBytes=9,this.readUInt64LE()}}readBigSize(){const t=this.readUInt8();if(t<253)return this._lastReadBytes=1,BigInt(t);switch(t){case 253:{this._lastReadBytes=3;const t=this.readUInt16BE();if(t<253)throw new Error("decoded varint is not canonical");return BigInt(t)}case 254:{this._lastReadBytes=5;const t=this.readUInt32BE();if(t<65536)throw new Error("decoded varint is not canonical");return BigInt(t)}case 255:{this._lastReadBytes=9;const t=this.readUInt64BE();if(t<BigInt(4294967296))throw new Error("decoded varint is not canonical");return t}default:throw new Error(`Unrecognised size: ${t} when trying to read BigSize`)}}readBytes(t){if(0===t)return this._lastReadBytes=0,o.alloc(0);if("number"==typeof t&&t>0){if(this._position+t>this._buffer.length)throw new RangeError("Index out of range");const e=this._buffer.subarray(this._position,this._position+t),i=o.alloc(e.length,e);return this._position+=t,this._lastReadBytes=t,i}{if(this._position===this._buffer.length)return this._lastReadBytes=0,o.alloc(0);const t=this._buffer.subarray(this._position),e=o.alloc(t.length,t);return this._position=this._buffer.length,this._lastReadBytes=e.length,e}}peakBytes(t){if(0===t)return o.alloc(0);if("number"==typeof t&&t>0){if(this._position+t>this._buffer.length)throw new RangeError("Index out of range");const e=this._buffer.subarray(this._position,this._position+t);return o.alloc(e.length,e)}{if(this._position===this._buffer.length)throw new RangeError("Index out of range");const t=this._buffer.subarray(this._position);return o.alloc(t.length,t)}}readTUInt16(){const t=Math.min(2,this._buffer.length-this._position);if(0===t)return 0;const e=this._buffer.readUIntBE(this._position,t);return this._assertMinimalTUInt(BigInt(e),t),this._position+=t,e}readTUInt32(){const t=Math.min(4,this._buffer.length-this._position);if(0===t)return 0;const e=this._buffer.readUIntBE(this._position,t);return this._assertMinimalTUInt(BigInt(e),t),this._position+=t,e}readTUInt64(){const t=Math.min(8,this._buffer.length-this._position);if(0===t)return BigInt(0);const e=this._buffer.subarray(this._position,this._position+t).toString("hex")||"0",i=BigInt("0x"+e);return this._assertMinimalTUInt(i,t),this._position+=t,i}_readStandard(t,e){if(this._position+e>this._buffer.length)throw new RangeError("Index out of range");const i=this._buffer[t](this._position);return this._position+=e,this._lastReadBytes=e,i}_assertMinimalTUInt(t,e){for(let i=0;i<9;i++)if(t<BigInt("0x1"+"".padStart(2*i,"0"))&&e!==i)throw new Error("TUInt not minimal")}}class k{constructor(t){this._position=void 0,this._fixed=void 0,this._buffer=void 0,this._position=0,this._fixed=!!t,this._buffer=t||o.alloc(0)}get size(){return this._position}toBuffer(){return this._fixed?this._buffer:this._buffer.subarray(0,this._position)}writeUInt8(t){this._writeStandard(this.writeUInt8.name,t,1)}writeUInt16LE(t){this._writeStandard(this.writeUInt16LE.name,t,2)}writeUInt16BE(t){this._writeStandard(this.writeUInt16BE.name,t,2)}writeUInt32LE(t){this._writeStandard(this.writeUInt32LE.name,t,4)}writeUInt32BE(t){this._writeStandard(this.writeUInt32BE.name,t,4)}writeUInt64LE(t){const e=BigInt(t);if(e<0||e>=BigInt(2)**BigInt(64))throw new RangeError(`The value of "value" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${t.toString()}`);const i=o.from(e.toString(16).padStart(16,"0"),"hex");this.writeBytes(i.reverse())}writeUInt64BE(t){const e=BigInt(t);if(e<0||e>=BigInt(2)**BigInt(64))throw new RangeError(`The value of "value" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${t.toString()}`);const i=o.from(e.toString(16).padStart(16,"0"),"hex");this.writeBytes(i)}writeBytes(t){t&&t.length&&(this._expand(t.length),t.copy(this._buffer,this._position),this._position+=t.length)}writeVarInt(t){const e=BigInt(t);e<BigInt(253)?this.writeUInt8(Number(e)):e<BigInt(65536)?(this.writeUInt8(253),this.writeUInt16LE(Number(e))):e<BigInt(4294967296)?(this.writeUInt8(254),this.writeUInt32LE(Number(e))):(this.writeUInt8(255),this.writeUInt64LE(e))}writeBigSize(t){const e=BigInt(t);e<BigInt(253)?this.writeUInt8(Number(e)):e<BigInt(65536)?(this.writeUInt8(253),this.writeUInt16BE(Number(e))):e<BigInt(4294967296)?(this.writeUInt8(254),this.writeUInt32BE(Number(e))):(this.writeUInt8(255),this.writeUInt64BE(e))}writeTUInt16(t){if(0===t)return;const e=t>255?2:1;this._expand(e),this._buffer.writeUIntBE(t,this._position,e),this._position+=e}writeTUInt32(t){if(0===t)return;const e=t>16777215?4:t>65535?3:t>255?2:1;this._expand(e),this._buffer.writeUIntBE(t,this._position,e),this._position+=e}writeTUInt64(t){if(t===BigInt(0))return;let e=t.toString(16);e.length%2==1&&(e="0"+e);const i=o.from(e,"hex");this.writeBytes(i)}_expand(t){const e=this._position+t;if(this._fixed&&e>this._buffer.length)throw new RangeError("Out of range");if(this._buffer.length<e){const t=1<<Math.ceil(Math.log2(e)),i=o.alloc(t);this._buffer.copy(i),this._buffer=i}}_writeStandard(t,e,i){this._expand(i),this._buffer[t](e,this._position),this._position+=i}}class A{static fromNumber(t){return new A(BigInt(t))}static fromBuffer(t){return 0===t.length?new A:new A(BigInt("0x"+t.toString("hex")))}constructor(t){this.value=void 0,this.value=t||BigInt(0)}isSet(t){return(this.value&BigInt(1)<<BigInt(t))>BigInt(0)}set(t){this.value|=BigInt(1)<<BigInt(t)}unset(t){this.value&=~(this.value&BigInt(1)<<BigInt(t))}toggle(t){this.value^=BigInt(1)<<BigInt(t)}flags(){const t=[];let e=0,i=1n;for(;i<this.value;)this.value&i&&t.push(e),e+=1,i<<=1n;return t}msb(){let t=this.value,e=0;for(;t>1;)t>>=1n,e+=1;return e}and(t){return new A(this.value&t.value)}or(t){return new A(this.value|t.value)}xor(t){return new A(this.value^t.value)}toBigInt(){return this.value}toNumber(){return Number(this.value)}toBuffer(){return this.value===BigInt(0)?o.alloc(0):function(t){const e=function(t){let e=0;for(;t>BigInt(0);)e+=1,t/=BigInt(256);return e}(t);return o.from(t.toString(16).padStart(2*e,"0"),"hex")}(this.value)}}var S,L,N;!function(t){t[t.Init=16]="Init",t[t.Error=17]="Error",t[t.Ping=18]="Ping",t[t.Pong=19]="Pong",t[t.OpenChannel=32]="OpenChannel",t[t.AcceptChannel=33]="AcceptChannel",t[t.FundingCreated=34]="FundingCreated",t[t.FundingSigned=35]="FundingSigned",t[t.FundingLocked=36]="FundingLocked",t[t.Shutdown=38]="Shutdown",t[t.ClosingSigned=39]="ClosingSigned",t[t.ChannelAnnouncement=256]="ChannelAnnouncement",t[t.NodeAnnouncement=257]="NodeAnnouncement",t[t.ChannelUpdate=258]="ChannelUpdate",t[t.AnnouncementSignatures=259]="AnnouncementSignatures",t[t.QueryShortChannelIds=261]="QueryShortChannelIds",t[t.ReplyShortChannelIdsEnd=262]="ReplyShortChannelIdsEnd",t[t.QueryChannelRange=263]="QueryChannelRange",t[t.ReplyChannelRange=264]="ReplyChannelRange",t[t.GossipTimestampFilter=265]="GossipTimestampFilter",t[t.CommandoRequest=19535]="CommandoRequest",t[t.CommandoResponseContinues=22859]="CommandoResponseContinues",t[t.CommandoResponse=22861]="CommandoResponse"}(S||(S={})),function(t){t[t.INITIATOR_INITIATING=0]="INITIATOR_INITIATING",t[t.AWAITING_INITIATOR=1]="AWAITING_INITIATOR",t[t.AWAITING_RESPONDER_REPLY=2]="AWAITING_RESPONDER_REPLY",t[t.AWAITING_INITIATOR_REPLY=3]="AWAITING_INITIATOR_REPLY",t[t.READY=100]="READY"}(L||(L={})),function(t){t[t.READY_FOR_LEN=2]="READY_FOR_LEN",t[t.READY_FOR_BODY=3]="READY_FOR_BODY",t[t.BLOCKED=4]="BLOCKED"}(N||(N={}));class C{constructor(){this.type=S.Init,this.features=new A,this.chainHashes=[]}static deserialize(t){const e=new C,i=new U(t);i.readUInt16BE();const s=i.readUInt16BE(),n=A.fromBuffer(i.readBytes(s)),r=i.readUInt16BE(),o=A.fromBuffer(i.readBytes(r));return e.features=(new A).or(n).or(o),function(t,e){let i=BigInt(-1);for(;!t.eof;)try{const s=t.readBigSize(),n=t.readBigSize(),r=t.readBytes(Number(n)),o=new U(r);if(s<=i)throw new Error("Invalid TLV stream");const h=s%BigInt(2)===BigInt(0),a=e(s,o);if(!a&&h)throw new Error("Unknown even type");if(a&&!o.eof)throw new Error("Non-canonical length");i=s}catch(t){}}(i,(t,i)=>{if(t===BigInt(1)){for(;!i.eof;){const t=i.readBytes(32);e.chainHashes.push(t)}return!0}return!1}),e}serialize(){const t=new k;t.writeUInt16BE(this.type),t.writeUInt16BE(0);const e=o.from([0,0,0,0,0,0,0,0]);return t.writeUInt16BE(e.length),t.writeBytes(e),this.chainHashes.length&&(t.writeBigSize(1),t.writeBigSize(32*this.chainHashes.length),t.writeBytes(o.concat(this.chainHashes))),t.toBuffer()}}class T{constructor(){this.type=S.Ping,this.numPongBytes=1,this.ignored=o.alloc(0)}static deserialize(t){const e=new U(t);e.readUInt16BE();const i=new T;i.numPongBytes=e.readUInt16BE();const s=e.readUInt16BE();return i.ignored=e.readBytes(s),i}serialize(){const t=new k(o.alloc(6+this.ignored.length));return t.writeUInt16BE(this.type),t.writeUInt16BE(this.numPongBytes),t.writeUInt16BE(this.ignored.length),t.writeBytes(this.ignored),t.toBuffer()}get triggersReply(){return this.numPongBytes<65532}}class x{static deserialize(t){const e=new x,i=new U(t);i.readUInt16BE();const s=i.readUInt16BE();return e.ignored=i.readBytes(s),e}constructor(t=0){this.type=S.Pong,this.ignored=void 0,this.ignored=o.alloc(t)}serialize(){const t=new k(o.alloc(+this.ignored.length+4));return t.writeUInt16BE(this.type),t.writeUInt16BE(this.ignored.length),t.writeBytes(this.ignored),t.toBuffer()}}class ${constructor(){this.type=S.CommandoResponse,this.id=void 0,this.response=void 0}static deserialize(t){const e=new $,i=new U(t);i.readUInt16BE(),e.id=i.readBytes(8).toString("hex");const s=i.readBytes(t.byteLength-26).toString();try{e.response=JSON.parse(s)}catch(t){e.response={jsonrpc:"2.0",id:null,error:{code:1,message:"Could not parse json response"}}}return e}}class P{constructor(i){this.noise=void 0,this.remoteNodePublicKey=void 0,this.publicKey=void 0,this.privateKey=void 0,this.wsUrl=void 0,this.socket=void 0,this.connected$=void 0,this.connecting=void 0,this.decryptedMsgs$=void 0,this.commandoMsgs$=void 0,this.Buffer=void 0,this._ls=void 0,this._es=void 0,this._handshakeState=void 0,this._readState=void 0,this._decryptedMsgs$=void 0,this._commandoMsgs$=void 0,this._partialCommandoMsgs=void 0,this._attemptedReconnects=void 0,this._logger=void 0,this._attemptReconnect=void 0,this._messageBuffer=void 0,this._processingBuffer=void 0,this._l=void 0,function(t){const{remoteNodePublicKey:e,wsProxy:i,privateKey:s,ip:n,port:r,logger:h}=t;if(!e||!a.publicKeyVerify(o.from(e,"hex")))throw new Error(`${e} is not a valid public key`);if(!n||!n.match(/^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)(\.(?!$)|$)){4}$/))throw new Error(`${n} is not a valid IP address`);if(!r||r<1||r>65535)throw new Error(`${r} is not a valid port number`);if(i){const t=`${i} is not a valid url`;try{const e=new URL(i);if("wss:"!==e.protocol&&"ws:"!==e.protocol)throw new Error(t)}catch(e){throw new Error(t)}}if(s&&!v(s))throw new Error(`${s} is not a valid private key`);if(h){if("object"!=typeof h)throw new Error("Logger must be of type object");const t=["info","warn","error"];Object.entries(h).forEach(([e,i])=>{if(!t.includes(e))throw new Error(`Invalid logger level: ${e}`);if("function"!=typeof i)throw new Error(`Logger for level: ${e} is not a function`)})}}(i);const{remoteNodePublicKey:n,wsProxy:r,privateKey:h,ip:d,port:l=9735,logger:u}=i;this._ls=o.from(h||b(),"hex"),this._es=o.from(b(),"hex"),this.noise=new R({ls:this._ls,es:this._es}),this.remoteNodePublicKey=n,this.publicKey=this.noise.lpk.toString("hex"),this.privateKey=this._ls.toString("hex"),this.wsUrl=r?`${r}/${d}:${l}`:`wss://${n}@${d}:${l}`,this.connected$=new t(!1),this.connecting=!1,this.Buffer=o,this._handshakeState=L.INITIATOR_INITIATING,this._decryptedMsgs$=new e,this.decryptedMsgs$=this._decryptedMsgs$.asObservable(),this._commandoMsgs$=new e,this.commandoMsgs$=this._commandoMsgs$.asObservable().pipe(s(({response:t,id:e})=>c({},t,{reqId:e}))),this._partialCommandoMsgs={},this._attemptedReconnects=0,this._logger=u,this._readState=N.READY_FOR_LEN,this._processingBuffer=!1,this._l=null,this.decryptedMsgs$.subscribe(t=>{this.handleDecryptedMessage(t)})}async connect(t=!0){var e=this;return!!this.connected$.getValue()||(this.connecting=!0,this._log("info",`Initiating connection to node ${this.remoteNodePublicKey}`),this._attemptReconnect=t,this._attemptedReconnects+=1,this.socket=new WebSocket(this.wsUrl),this.socket.binaryType="arraybuffer",this.socket.onopen=async function(){e._log("info","WebSocket is connected"),e._log("info","Creating Act1 message");const t=await e.noise.initiatorAct1(o.from(e.remoteNodePublicKey,"hex"));e.socket&&(e._log("info","Sending Act1 message"),e.socket.send(t),e._handshakeState=L.AWAITING_RESPONDER_REPLY)},this.socket.onclose=async function(){e._log("error","WebSocket is closed"),e._log("info",`Attempted reconnects: ${e._attemptedReconnects}`),e.connected$.next(!1),e._attemptReconnect&&e._attemptedReconnects<5&&(e.connecting=!0,e._log("info","Waiting to reconnect"),await new Promise(t=>setTimeout(t,1e3*(e._attemptedReconnects||1))),e.connect())},this.socket.onerror=t=>{this._log("error",`WebSocket error: ${JSON.stringify(t)}`)},this.socket.onmessage=this.queueMessage.bind(this),i(this.connected$.pipe(n(1))))}queueMessage(t){const{data:e}=t,i=o.from(e),s=this._messageBuffer&&!this._messageBuffer.eof&&this._messageBuffer.readBytes();this._messageBuffer=new U(s?o.concat([s,i]):i),this._processingBuffer||(this._processingBuffer=!0,this._processBuffer())}disconnect(){this._log("info","Manually disconnecting from WebSocket"),this.noise=new R({ls:this._ls,es:this._es}),this._attemptReconnect=!1,this.socket&&this.socket.close()}async _processBuffer(){try{let t=!0;do{if(this._handshakeState!==L.READY)switch(this._handshakeState){case L.INITIATOR_INITIATING:throw new Error("Received data before intialised");case L.AWAITING_RESPONDER_REPLY:t=await this._processResponderReply()}else switch(this._readState){case N.READY_FOR_LEN:t=await this._processPacketLength();break;case N.READY_FOR_BODY:t=await this._processPacketBody();break;case N.BLOCKED:t=!1;break;default:throw new Error("Unknown read state")}}while(t)}catch(t){this.disconnect()}this._processingBuffer=!1}async _processResponderReply(){const t=this._messageBuffer.readBytes(50);if(50!==t.byteLength)throw new Error("Invalid message received from remote node");this._log("info","Validating message as part of Act2"),await this.noise.initiatorAct2(t),this._log("info","Creating reply for Act3");const e=await this.noise.initiatorAct3();return this.socket&&(this._log("info","Sending reply for act3"),this.socket.send(e),this._handshakeState=L.READY),!0}async _processPacketLength(){try{const t=this._messageBuffer.readBytes(18);if(!t)return!1;const e=await this.noise.decryptLength(t);return this._l=e,this._readState=N.READY_FOR_BODY,!0}catch(t){return!1}}async _processPacketBody(){if(!this._l)return!1;try{const t=this._messageBuffer.readBytes(this._l+16);if(!t)return!1;const e=await this.noise.decryptMessage(t);return this._l=null,this._decryptedMsgs$.next(e),this._readState=N.READY_FOR_LEN,!0}catch(t){return!1}}async handleDecryptedMessage(t){try{const e=new U(t),i=e.readUInt16BE(),[s]=Object.entries(S).find(([t,e])=>e===i)||[],n=e.readBytes(8).toString("hex"),r=e.readBytes();if(this._log("info",`Message type is: ${s||"unknown"}`),i===S.CommandoResponseContinues)return this._log("info","Received a partial commando message, caching it to join with other parts"),void(this._partialCommandoMsgs[n]=this._partialCommandoMsgs[n]?o.concat([this._partialCommandoMsgs[n],r.subarray(0,r.byteLength-16)]):t.subarray(0,t.length-16));i===S.CommandoResponse&&this._partialCommandoMsgs[n]&&(this._log("info","Received a final commando msg and we have a partial message to join it to. Joining now"),t=o.concat([this._partialCommandoMsgs[n],r]),delete this._partialCommandoMsgs[n]),this._log("info","Deserialising payload");const h=function(t){const e=t.readUInt16BE(0);switch(e){case S.Init:return C.deserialize(t);case S.Ping:return T.deserialize(t);case S.Pong:return x.deserialize(t);case S.CommandoResponse:case S.CommandoResponseContinues:return $.deserialize(t)}return{type:e}}(t);switch(h.type){case S.Init:{this._log("info","Constructing Init message reply");const t=await this.noise.encryptMessage(h.serialize());this.socket&&(this._log("info","Sending Init message reply"),this.socket.send(t),this._log("info","Connected and ready to send messages!"),this.connected$.next(!0),this.connecting=!1,this._attemptedReconnects=0);break}case S.Ping:{this._log("info","Received a Ping message"),this._log("info","Creating a Pong message");const t=new x(h.numPongBytes).serialize(),e=await this.noise.encryptMessage(t);this.socket&&(this._log("info","Sending a Pong message"),this.socket.send(e));break}case S.CommandoResponse:this._commandoMsgs$.next(h)}}catch(t){this._log("error",`Error handling incoming message: ${t.message}`)}}async commando({method:t,params:e=[],rune:s,reqId:n}){this._log("info",`Commando request method: ${t} params: ${JSON.stringify(e)}`),this.connected$.getValue()||this.connecting?(this._log("info","Ensuring we have a connection before making request"),await i(this.connected$.pipe(r(t=>!0===t)))):(this._log("info","No socket connection, so creating one now"),await this.connect());const h=new k;if(!n){const t=o.allocUnsafe(8),e=window.crypto.getRandomValues(t);n=e.toString("hex")}h.writeUInt16BE(S.CommandoRequest),h.writeBytes(o.from(n,"hex")),h.writeBytes(o.from(JSON.stringify({rune:s,method:t,params:e}))),this._log("info","Creating message to send");const a=await this.noise.encryptMessage(h.toBuffer());if(this.socket){this._log("info","Sending commando message"),this.socket.send(a),this._log("info","Message sent and awaiting response");const{response:t}=await i(this._commandoMsgs$.pipe(r(t=>t.id===n))),{result:e}=t,{error:s}=t;if(this._log("info",e?"Successful response received":`Error response received: ${s.message}`),s)throw s;return e}throw new Error("No socket initialised and connected")}_log(t,e){this._logger&&this._logger[t]&&this._logger[t](`[${t.toUpperCase()} - ${(new Date).toLocaleTimeString()}]: ${e}`)}}export{P as default};
//# sourceMappingURL=index.modern.js.map
