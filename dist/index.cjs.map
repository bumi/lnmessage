{"version":3,"file":"index.cjs","sources":["../src/chacha/chacha20.ts","../src/chacha/poly1305.ts","../src/chacha/index.ts","../src/crypto.ts","../src/noise-state.ts","../src/types.ts","../src/messages/buf.ts","../src/messages/BitField.ts","../src/messages/BigIntUtils.ts","../src/messages/InitMessage.ts","../src/messages/read-tlvs.ts","../src/messages/PingMessage.ts","../src/messages/PongMessage.ts","../src/messages/CommandoMessage.ts","../src/index.ts","../src/validation.ts","../src/messages/MessageFactory.ts"],"sourcesContent":["import { Buffer } from 'buffer'\n\nfunction ROTATE(v: number, c: number) {\n  return (v << c) | (v >>> (32 - c))\n}\n\nconst constants = Buffer.from('expand 32-byte k')\n\nclass Chacha20 {\n  public input: Uint32Array\n  public cachePos: number\n  public buffer: Uint32Array\n  public output: Buffer\n\n  constructor(key: Buffer, nonce: Buffer) {\n    this.input = new Uint32Array(16)\n\n    // https://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-01#section-2.3\n    this.input[0] = constants.readUInt32LE(0)\n    this.input[1] = constants.readUInt32LE(4)\n    this.input[2] = constants.readUInt32LE(8)\n    this.input[3] = constants.readUInt32LE(12)\n    this.input[4] = key.readUInt32LE(0)\n    this.input[5] = key.readUInt32LE(4)\n    this.input[6] = key.readUInt32LE(8)\n    this.input[7] = key.readUInt32LE(12)\n    this.input[8] = key.readUInt32LE(16)\n    this.input[9] = key.readUInt32LE(20)\n    this.input[10] = key.readUInt32LE(24)\n    this.input[11] = key.readUInt32LE(28)\n\n    this.input[12] = 0\n\n    this.input[13] = nonce.readUInt32LE(0)\n    this.input[14] = nonce.readUInt32LE(4)\n    this.input[15] = nonce.readUInt32LE(8)\n\n    this.cachePos = 64\n    this.buffer = new Uint32Array(16)\n    this.output = new Buffer(64)\n  }\n\n  quarterRound(a: number, b: number, c: number, d: number) {\n    const x = this.buffer\n    x[a] += x[b]\n    x[d] = ROTATE(x[d] ^ x[a], 16)\n    x[c] += x[d]\n    x[b] = ROTATE(x[b] ^ x[c], 12)\n    x[a] += x[b]\n    x[d] = ROTATE(x[d] ^ x[a], 8)\n    x[c] += x[d]\n    x[b] = ROTATE(x[b] ^ x[c], 7)\n  }\n\n  makeBlock(output: Buffer, start: number) {\n    let i = -1\n    // copy input into working buffer\n    while (++i < 16) {\n      this.buffer[i] = this.input[i]\n    }\n    i = -1\n    while (++i < 10) {\n      // straight round\n      this.quarterRound(0, 4, 8, 12)\n      this.quarterRound(1, 5, 9, 13)\n      this.quarterRound(2, 6, 10, 14)\n      this.quarterRound(3, 7, 11, 15)\n\n      //diaganle round\n      this.quarterRound(0, 5, 10, 15)\n      this.quarterRound(1, 6, 11, 12)\n      this.quarterRound(2, 7, 8, 13)\n      this.quarterRound(3, 4, 9, 14)\n    }\n\n    i = -1\n\n    // copy working buffer into output\n    while (++i < 16) {\n      this.buffer[i] += this.input[i]\n      output.writeUInt32LE(this.buffer[i], start)\n      start += 4\n    }\n\n    this.input[12]++\n\n    if (!this.input[12]) {\n      throw new Error('counter is exausted')\n    }\n  }\n\n  getBytes(len: number) {\n    let dpos = 0\n    const dst = new Buffer(len)\n    const cacheLen = 64 - this.cachePos\n\n    if (cacheLen) {\n      if (cacheLen >= len) {\n        this.output.copy(dst, 0, this.cachePos, 64)\n        this.cachePos += len\n        return dst\n      } else {\n        this.output.copy(dst, 0, this.cachePos, 64)\n        len -= cacheLen\n        dpos += cacheLen\n        this.cachePos = 64\n      }\n    }\n\n    while (len > 0) {\n      if (len <= 64) {\n        this.makeBlock(this.output, 0)\n        this.output.copy(dst, dpos, 0, len)\n        if (len < 64) {\n          this.cachePos = len\n        }\n        return dst\n      } else {\n        this.makeBlock(dst, dpos)\n      }\n      len -= 64\n      dpos += 64\n    }\n\n    throw new Error('something bad happended')\n  }\n}\n\nexport default Chacha20\n","import { Buffer } from 'buffer'\n\nclass Poly1305 {\n  public buffer: Buffer\n  public leftover: number\n  public r: Uint16Array\n  public h: Uint16Array\n  public pad: Uint16Array\n  public finished: number\n\n  constructor(key: Buffer) {\n    this.buffer = new Buffer(16)\n    this.leftover = 0\n    this.r = new Uint16Array(10)\n    this.h = new Uint16Array(10)\n    this.pad = new Uint16Array(8)\n    this.finished = 0\n\n    let t = new Uint16Array(8),\n      i\n\n    for (i = 8; i--; ) t[i] = key.readUInt16LE(i * 2)\n\n    this.r[0] = t[0] & 0x1fff\n    this.r[1] = ((t[0] >>> 13) | (t[1] << 3)) & 0x1fff\n    this.r[2] = ((t[1] >>> 10) | (t[2] << 6)) & 0x1f03\n    this.r[3] = ((t[2] >>> 7) | (t[3] << 9)) & 0x1fff\n    this.r[4] = ((t[3] >>> 4) | (t[4] << 12)) & 0x00ff\n    this.r[5] = (t[4] >>> 1) & 0x1ffe\n    this.r[6] = ((t[4] >>> 14) | (t[5] << 2)) & 0x1fff\n    this.r[7] = ((t[5] >>> 11) | (t[6] << 5)) & 0x1f81\n    this.r[8] = ((t[6] >>> 8) | (t[7] << 8)) & 0x1fff\n    this.r[9] = (t[7] >>> 5) & 0x007f\n\n    for (i = 8; i--; ) {\n      this.h[i] = 0\n      this.pad[i] = key.readUInt16LE(16 + 2 * i)\n    }\n    this.h[8] = 0\n    this.h[9] = 0\n    this.leftover = 0\n    this.finished = 0\n  }\n\n  blocks(m: Buffer, mpos: number, bytes: number) {\n    const hibit = this.finished ? 0 : 1 << 11\n    let t = new Uint16Array(8),\n      d = new Uint32Array(10),\n      c = 0,\n      i = 0,\n      j = 0\n\n    while (bytes >= 16) {\n      for (i = 8; i--; ) t[i] = m.readUInt16LE(i * 2 + mpos)\n\n      this.h[0] += t[0] & 0x1fff\n      this.h[1] += ((t[0] >>> 13) | (t[1] << 3)) & 0x1fff\n      this.h[2] += ((t[1] >>> 10) | (t[2] << 6)) & 0x1fff\n      this.h[3] += ((t[2] >>> 7) | (t[3] << 9)) & 0x1fff\n      this.h[4] += ((t[3] >>> 4) | (t[4] << 12)) & 0x1fff\n      this.h[5] += (t[4] >>> 1) & 0x1fff\n      this.h[6] += ((t[4] >>> 14) | (t[5] << 2)) & 0x1fff\n      this.h[7] += ((t[5] >>> 11) | (t[6] << 5)) & 0x1fff\n      this.h[8] += ((t[6] >>> 8) | (t[7] << 8)) & 0x1fff\n      this.h[9] += (t[7] >>> 5) | hibit\n\n      for (i = 0, c = 0; i < 10; i++) {\n        d[i] = c\n        for (j = 0; j < 10; j++) {\n          d[i] += (this.h[j] & 0xffffffff) * (j <= i ? this.r[i - j] : 5 * this.r[i + 10 - j])\n          if (j === 4) {\n            c = d[i] >>> 13\n            d[i] &= 0x1fff\n          }\n        }\n        c += d[i] >>> 13\n        d[i] &= 0x1fff\n      }\n      c = (c << 2) + c\n      c += d[0]\n      d[0] = c & 0xffff & 0x1fff\n      c = c >>> 13\n      d[1] += c\n\n      for (i = 10; i--; ) this.h[i] = d[i]\n\n      mpos += 16\n      bytes -= 16\n    }\n  }\n\n  update(m: Buffer) {\n    let bytes = m.length\n    let want = 0,\n      i = 0,\n      mpos = 0\n\n    if (this.leftover) {\n      want = 16 - this.leftover\n      if (want > bytes) want = bytes\n      for (i = want; i--; ) {\n        this.buffer[this.leftover + i] = m[i + mpos]\n      }\n      bytes -= want\n      mpos += want\n      this.leftover += want\n      if (this.leftover < 16) return this\n      this.blocks(this.buffer, 0, 16)\n      this.leftover = 0\n    }\n\n    if (bytes >= 16) {\n      want = bytes & ~(16 - 1)\n      this.blocks(m, mpos, want)\n      mpos += want\n      bytes -= want\n    }\n\n    if (bytes) {\n      for (i = bytes; i--; ) {\n        this.buffer[this.leftover + i] = m[i + mpos]\n      }\n      this.leftover += bytes\n    }\n    return this\n  }\n\n  finish() {\n    let mac = new Buffer(16),\n      g = new Uint16Array(10),\n      c = 0,\n      mask = 0,\n      f = 0,\n      i = 0\n    if (this.leftover) {\n      i = this.leftover\n      this.buffer[i++] = 1\n      for (; i < 16; i++) {\n        this.buffer[i] = 0\n      }\n      this.finished = 1\n      this.blocks(this.buffer, 0, 16)\n    }\n\n    c = this.h[1] >>> 13\n    this.h[1] &= 0x1fff\n    for (i = 2; i < 10; i++) {\n      this.h[i] += c\n      c = this.h[i] >>> 13\n      this.h[i] &= 0x1fff\n    }\n    this.h[0] += c * 5\n    c = this.h[0] >>> 13\n    this.h[0] &= 0x1fff\n    this.h[1] += c\n    c = this.h[1] >>> 13\n    this.h[1] &= 0x1fff\n    this.h[2] += c\n\n    g[0] = this.h[0] + 5\n    c = g[0] >>> 13\n    g[0] &= 0x1fff\n    for (i = 1; i < 10; i++) {\n      g[i] = this.h[i] + c\n      c = g[i] >>> 13\n      g[i] &= 0x1fff\n    }\n    g[9] -= 1 << 13\n\n    mask = (g[9] >>> 15) - 1\n    for (i = 10; i--; ) g[i] &= mask\n    mask = ~mask\n    for (i = 10; i--; ) {\n      this.h[i] = (this.h[i] & mask) | g[i]\n    }\n\n    this.h[0] = this.h[0] | (this.h[1] << 13)\n    this.h[1] = (this.h[1] >> 3) | (this.h[2] << 10)\n    this.h[2] = (this.h[2] >> 6) | (this.h[3] << 7)\n    this.h[3] = (this.h[3] >> 9) | (this.h[4] << 4)\n    this.h[4] = (this.h[4] >> 12) | (this.h[5] << 1) | (this.h[6] << 14)\n    this.h[5] = (this.h[6] >> 2) | (this.h[7] << 11)\n    this.h[6] = (this.h[7] >> 5) | (this.h[8] << 8)\n    this.h[7] = (this.h[8] >> 8) | (this.h[9] << 5)\n\n    f = (this.h[0] & 0xffffffff) + this.pad[0]\n    this.h[0] = f\n    for (i = 1; i < 8; i++) {\n      f = (this.h[i] & 0xffffffff) + this.pad[i] + (f >>> 16)\n      this.h[i] = f\n    }\n\n    for (i = 8; i--; ) {\n      mac.writeUInt16LE(this.h[i], i * 2)\n      this.pad[i] = 0\n    }\n    for (i = 10; i--; ) {\n      this.h[i] = 0\n      this.r[i] = 0\n    }\n\n    return mac\n  }\n}\n\nexport default Poly1305\n","import { Buffer } from 'buffer'\nimport Chacha20 from './chacha20.js'\nimport Poly1305 from './poly1305.js'\n\nclass Cipher {\n  private alen: number\n  private clen: number\n  private chacha: Chacha20\n  private poly: Poly1305\n  private tag: null | Buffer\n  private _decrypt: boolean\n  private _hasData: boolean\n\n  constructor(key: Buffer, iv: Buffer, decrypt: boolean = false) {\n    this.alen = 0\n    this.clen = 0\n    this.chacha = new Chacha20(key, iv)\n    this.poly = new Poly1305(this.chacha.getBytes(64))\n    this.tag = null\n    this._decrypt = decrypt\n    this._hasData = false\n  }\n\n  setAAD(aad: Buffer) {\n    if (this._hasData) {\n      throw new Error('Attempting to set AAD in unsupported state')\n    }\n    this.alen = aad.length\n    this.poly.update(aad)\n    const padding = new Buffer(padAmount(this.alen))\n    if (padding.length) {\n      padding.fill(0)\n      this.poly.update(padding)\n    }\n  }\n\n  update(data: string | Buffer, inputEnc?: BufferEncoding, outputEnc?: BufferEncoding) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data, inputEnc)\n    }\n\n    let outData = this._update(data) || Buffer.from('')\n\n    return outputEnc ? outData.toString(outputEnc) : outData\n  }\n\n  final(outputEnc?: BufferEncoding) {\n    let outData = this._final() || Buffer.from('')\n\n    return outputEnc ? outData.toString(outputEnc) : outData\n  }\n\n  _update(chunk: Buffer) {\n    if (!this._hasData) {\n      this._hasData = true\n    }\n\n    const len = chunk.length\n\n    if (!len) {\n      return\n    }\n\n    this.clen += len\n    const pad = this.chacha.getBytes(len)\n\n    let i = -1\n    while (++i < len) {\n      pad[i] ^= chunk[i]\n    }\n\n    if (this._decrypt) {\n      this.poly.update(chunk)\n    } else {\n      this.poly.update(pad)\n    }\n\n    return pad\n  }\n\n  _final() {\n    if (this._decrypt && !this.tag) {\n      throw new Error('Unsupported state or unable to authenticate data')\n    }\n\n    const padding = new Buffer(padAmount(this.clen))\n\n    if (padding.length) {\n      padding.fill(0)\n      this.poly.update(padding)\n    }\n\n    const lens = new Buffer(16)\n    lens.fill(0)\n    lens.writeUInt32LE(this.alen, 0)\n    lens.writeUInt32LE(this.clen, 8)\n\n    const tag = this.poly.update(lens).finish()\n\n    if (this._decrypt) {\n      if (xorTest(tag, this.tag as Buffer)) {\n        throw new Error('Unsupported state or unable to authenticate data')\n      }\n    } else {\n      this.tag = tag\n    }\n\n    return tag\n  }\n\n  getAuthTag() {\n    if (this._decrypt || this.tag === null) {\n      return new Buffer('')\n    }\n    return this.tag\n  }\n\n  setAuthTag(tag: Buffer) {\n    if (this._decrypt) {\n      this.tag = tag\n    } else {\n      throw new Error('Attempting to set auth tag in unsupported state')\n    }\n  }\n}\n\nfunction padAmount(len: number) {\n  const rem = len % 16\n  return rem ? 16 - rem : 0\n}\n\nfunction xorTest(a: Buffer, b: Buffer) {\n  let out = 0\n\n  if (a.length !== b.length) {\n    out++\n  }\n\n  const len = Math.min(a.length, b.length)\n\n  let i = -1\n  while (++i < len) {\n    out += a[i] ^ b[i]\n  }\n\n  return out\n}\n\nexport function createDecipher(key: Buffer, iv: Buffer) {\n  return new Cipher(key, iv, true)\n}\n\nexport function createCipher(key: Buffer, iv: Buffer) {\n  return new Cipher(key, iv)\n}\n","import CryptoJS from 'crypto-js'\nimport { Buffer } from 'buffer'\nimport secp256k1 from 'secp256k1'\nimport { createCipher, createDecipher } from './chacha/index.js'\n\nexport function ecdh(pubkey: Uint8Array, privkey: Uint8Array) {\n  return Buffer.from(secp256k1.ecdh(pubkey, privkey))\n}\n\nexport function hmacHash(key: Buffer, input: Buffer) {\n  const words = CryptoJS.HmacSHA256(\n    CryptoJS.enc.Hex.parse(input.toString('hex')),\n    CryptoJS.enc.Hex.parse(key.toString('hex'))\n  )\n\n  return Buffer.from(CryptoJS.enc.Hex.stringify(words), 'hex')\n}\n\nexport async function sha256(input: Buffer): Promise<Buffer> {\n  const res = await window.crypto.subtle.digest('SHA-256', input)\n  return Buffer.from(res)\n}\n\nexport function hkdf(ikm: Buffer, len: number, salt = Buffer.alloc(0), info = Buffer.alloc(0)) {\n  // extract step\n  const prk = hmacHash(salt, ikm)\n\n  // expand\n  const n = Math.ceil(len / prk.byteLength)\n  if (n > 255) throw new Error('Output length exceeds maximum')\n\n  const t = [Buffer.alloc(0)]\n\n  for (let i = 1; i <= n; i++) {\n    const tp = t[t.length - 1]\n    const bi = Buffer.from([i])\n    t.push(hmacHash(prk, Buffer.concat([tp, info, bi])))\n  }\n\n  return Buffer.concat(t.slice(1)).subarray(0, len)\n}\n\nexport function getPublicKey(privKey: Buffer, compressed = true) {\n  return Buffer.from(secp256k1.publicKeyCreate(privKey, compressed))\n}\n\n/**\n * Encrypt data using authenticated encryption with associated data (AEAD)\n * ChaCha20-Poly1305.\n *\n * @param k private key, 64-bytes\n * @param n nonce, 12-bytes\n * @param ad associated data\n * @param plaintext raw data to encrypt\n * @returns encrypted data + tag as a variable length buffer\n */\nexport function ccpEncrypt(k: Buffer, n: Buffer, ad: Buffer, plaintext: Buffer): Buffer {\n  const cipher = createCipher(k, n)\n  cipher.setAAD(ad)\n\n  const pad = cipher.update(plaintext) as Buffer\n\n  cipher.final && cipher.final()\n  const tag = cipher.getAuthTag()\n  return Buffer.concat([pad, tag])\n}\n\n/**\n * Decrypt data uusing authenticated encryption with associated data (AEAD)\n * ChaCha20-Poly1305\n *\n * @param k private key, 64-bytes\n * @param n nonce, 12-bytes\n * @param ad associated data, variable length\n * @param ciphertext encrypted data to decrypt\n * @returns decrypteed data as a variable length Buffer\n */\nexport function ccpDecrypt(k: Buffer, n: Buffer, ad: Buffer, ciphertext: Buffer) {\n  const decipher = createDecipher(k, n)\n\n  decipher.setAAD(ad)\n\n  if (ciphertext.length === 16) {\n    decipher.setAuthTag(ciphertext)\n    return decipher.final()\n  }\n\n  if (ciphertext.length > 16) {\n    const tag = ciphertext.subarray(ciphertext.length - 16)\n    const pad = ciphertext.subarray(0, ciphertext.length - 16)\n    decipher.setAuthTag(tag)\n    let m = decipher.update(pad)\n    const f = decipher.final()\n    m = Buffer.concat([m as Buffer, f as Buffer])\n    return m\n  }\n}\n\nexport function createRandomPrivateKey(): string {\n  let privKey\n  do {\n    const bytes = Buffer.allocUnsafe(32)\n    privKey = window.crypto.getRandomValues(bytes)\n  } while (!validPrivateKey(privKey))\n\n  return privKey.toString('hex')\n}\n\nexport function validPublicKey(publicKey: string): boolean {\n  return secp256k1.publicKeyVerify(Buffer.from(publicKey, 'hex'))\n}\n\nexport function validPrivateKey(privateKey: string | Buffer): boolean {\n  return secp256k1.privateKeyVerify(\n    typeof privateKey === 'string' ? Buffer.from(privateKey, 'hex') : privateKey\n  )\n}\n","import { ccpDecrypt, ccpEncrypt, ecdh, getPublicKey, hkdf, sha256 } from './crypto.js'\nimport type { NoiseStateOptions } from './types'\nimport { Buffer } from 'buffer'\n\nexport class NoiseState {\n  /**\n   * The official protocol name for the Lightning variant of Noise. This\n   * value is mixed into the iniitialiization function to start the\n   * handshake.\n   */\n  public protocolName = Buffer.from('Noise_XK_secp256k1_ChaChaPoly_SHA256')\n  /**\n   * Appended to the hash of the protocolName during initialization.\n   */\n  public prologue = Buffer.from('lightning')\n  /**\n   * Local secret is a 32-bit private key valid in elliptic curve\n   * secp256k1. This value is unique to the node and should be\n   * chosen with strong cryptographic randomness.\n   */\n  public ls: Buffer\n  /**\n   * Local compressed public key derviced from the local secret `ls`.\n   * This value is stored as a 33-byte buffer.\n   */\n  public lpk: Buffer\n  /**\n   * Ephemeral secret is a 32-bit private key valid in elliptic curve\n   * secp256k1. This value is generated by each node for each connection.\n   * This value must be generated with strong cryptographic randomness.\n   */\n  public es: Buffer\n  /**\n   * Ephemeral compressed public key derived from the ephemeral secret\n   * `es`. This value is stored as a 33-byte buffer.\n   */\n  public epk: Buffer\n  /**\n   * Remote compressed public key stored as a 33-byte buffer.\n   */\n  public rpk: Buffer\n  /**\n   * Remote party's ephemeral public key as a 33-byte buffer storing\n   * the compressed public key. This value is extracted in act 2 where\n   * it is sent during act 1 to the opposing side.\n   */\n  public repk: Buffer\n  /**\n   * Hanshake hash. This value is the accumulated hash of all handshake data that\n   * has been sent and received during the handshake process.\n   */\n  public h: Buffer\n  /**\n   * Chaining key. This value is the accumulated hash of all previous ECDH outputs.\n   * At the end of the handshake, `ck` is used to dervice the encryption keys\n   * for messages.\n   */\n  public ck: Buffer\n  /**\n   * The key used is the receiving key used to decrypt messages sent by the\n   * other side. It is generated in Act3.\n   */\n  public rk: Buffer\n  /**\n   * The key used by the sender to encrypt messages to the receiver. This value\n   * is generated in Act3.\n   */\n  public sk: Buffer\n  /**\n   * Nonce incremented when sending messages. Initialized to zero in Act3.\n   */\n  public sn: Buffer\n  /**\n   * Nonce incremented when receiving messages. Initialized to zero in Act3.\n   */\n  public rn: Buffer\n  /**\n   * Intermediate key 1. Used to encrypt or decrypt the zero-length AEAD\n   * payload in the corresponding initiator or receiver act.\n   */\n  public tempK1: Buffer\n  /**\n   * Intermediate key 2. Used to encrypt or decrypt the zero-length AEAD\n   * payload in the corresponding initiator or receiver act.\n   */\n  public tempK2: Buffer\n  /**\n   * Intermediate key 3. Used to encrypt or decrypt the zero-length AEAD\n   * payload in the corresponding initiator or receiver act.\n   */\n  public tempK3: Buffer\n  /**\n   * State machine for perforing noise-protocol handshake, message\n   * encryption and decryption, and key rotation.\n   */\n  constructor({ ls, es }: NoiseStateOptions) {\n    this.ls = ls\n    this.lpk = getPublicKey(ls)\n    this.es = es\n    this.epk = getPublicKey(es)\n  }\n  /**\n   * Initiator Act1 is the starting point for the authenticated key exchange\n   * handshake. The initiator attempts to satisfy an implicit challenge by the\n   * responder: knowledge of the static public key of the responder. It also\n   * transmits the initiators ephemeral key.\n   * @param rpk remote public key\n   * @return Buffer that is 50 bytes\n   */\n  public async initiatorAct1(rpk: Buffer): Promise<Buffer> {\n    this.rpk = rpk\n    await this._initialize(this.rpk)\n\n    // 2. h = SHA-256(h || epk)\n    this.h = await sha256(Buffer.concat([this.h, this.epk]))\n\n    // 3. es = ECDH(e.priv, rs)\n    const ss = ecdh(this.rpk, this.es)\n\n    // 4. ck, temp_k1 = HKDF(ck, es)\n    const tempK1 = hkdf(ss, 64, this.ck)\n    this.ck = tempK1.subarray(0, 32)\n    this.tempK1 = tempK1.subarray(32)\n\n    // 5. c = encryptWithAD(temp_k1, 0, h, zero)\n    const c = ccpEncrypt(this.tempK1, Buffer.alloc(12), this.h, Buffer.alloc(0))\n\n    // 6. h = SHA-256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 7. m = 0 || epk || c\n    const m = Buffer.concat([Buffer.alloc(1), this.epk, c])\n    return m\n  }\n  /**\n   * Initiator Act2 handles the response generated by the receiver's\n   * Act1, a 50-byte message. The responder's ephemeral key is extacted\n   * from the message during this phase.\n   *\n   * @param m 50-byte message from responder's act1\n   */\n  public async initiatorAct2(m: Buffer) {\n    // 1. read exactly 50 bytes off the stream\n    if (m.length !== 50) throw new Error('ACT2_READ_FAILED')\n    // 2. parse th read message m into v, re, and c\n    const v = m.subarray(0, 1)[0]\n    const re = m.subarray(1, 34)\n    const c = m.subarray(34)\n    // 2a. convert re to public key\n    this.repk = re\n    // 3. assert version is known version\n    if (v !== 0) throw new Error('ACT2_BAD_VERSION')\n    // 4. sha256(h || re.serializedCompressed');\n    this.h = await sha256(Buffer.concat([this.h, this.repk]))\n    // 5. ss = ECDH(re, e.priv);\n    const ss = ecdh(this.repk, this.es)\n    // 6. ck, temp_k2 = HKDF(cd, ss)\n    const tempK2 = hkdf(ss, 64, this.ck)\n    this.ck = tempK2.subarray(0, 32)\n    this.tempK2 = tempK2.subarray(32)\n    // 7. p = decryptWithAD()\n    ccpDecrypt(this.tempK2, Buffer.alloc(12), this.h, c)\n    // 8. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n  }\n  /**\n   * Initiator Act3 is the final phase in the authenticated\n   * key agreement. This act is executed only if act 2\n   * was successful. The initiator transports its static public key\n   * to the responder.\n   */\n  public async initiatorAct3() {\n    // 1. c = encryptWithAD(temp_k2, 1, h, lpk)\n    const c = ccpEncrypt(\n      this.tempK2,\n      Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]),\n      this.h,\n      this.lpk\n    )\n    // 2. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 3. ss = ECDH(re, s.priv)\n    const ss = ecdh(this.repk, this.ls)\n    // 4. ck, temp_k3 = HKDF(ck, ss)\n    const tempK3 = hkdf(ss, 64, this.ck)\n    this.ck = tempK3.subarray(0, 32)\n    this.tempK3 = tempK3.subarray(32)\n    // 5. t = encryptWithAD(temp_k3, 0, h, zero)\n    const t = ccpEncrypt(this.tempK3, Buffer.alloc(12), this.h, Buffer.alloc(0))\n    // 6. sk, rk = hkdf(ck, zero)\n    const sk = hkdf(Buffer.alloc(0), 64, this.ck)\n    this.rk = sk.subarray(32)\n    this.sk = sk.subarray(0, 32)\n    // 7. rn = 0, sn = 0\n    this.sn = Buffer.alloc(12)\n    this.rn = Buffer.alloc(12)\n    // 8. send m = 0 || c || t\n    const m = Buffer.concat([Buffer.alloc(1), c, t])\n    return m\n  }\n  /**\n   * Receiver Act1 extracts the initiators ephemeral key. It also\n   * validates that the initiator knows the receivers public key.\n   * @param m 50-byte message sent by the initiator\n   */\n  public async receiveAct1(m: Buffer) {\n    await this._initialize(this.lpk)\n    // 1. read exactly 50 bytes off the stream\n    if (m.length !== 50) throw new Error('ACT1_READ_FAILED')\n    // 2. parse th read message m into v,re, and c\n    const v = m.subarray(0, 1)[0]\n    const re = m.subarray(1, 34)\n    const c = m.subarray(34)\n    this.repk = re\n    // 3. assert version is known version\n    if (v !== 0) throw new Error('ACT1_BAD_VERSION')\n    // 4. sha256(h || re.serializedCompressed');\n    this.h = await sha256(Buffer.concat([this.h, re]))\n    // 5. ss = ECDH(re, ls.priv);\n    const ss = ecdh(re, this.ls)\n    // 6. ck, temp_k1 = HKDF(cd, ss)\n    const tempK1 = hkdf(ss, 64, this.ck)\n    this.ck = tempK1.subarray(0, 32)\n    this.tempK1 = tempK1.subarray(32)\n    // 7. p = decryptWithAD(temp_k1, 0, h, c)\n    ccpDecrypt(this.tempK1, Buffer.alloc(12), this.h, c)\n    // 8. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n  }\n  /**\n   * Receiver Act2 takes place only if Act1 was successful.\n   * This act sends responder's ephermeral key to the initiator.\n   */\n  public async recieveAct2(): Promise<Buffer> {\n    // 1. e = generateKey() => done in initialization\n    // 2. h = sha256(h || e.pub.compressed())\n    this.h = await sha256(Buffer.concat([this.h, this.epk]))\n    // 3. ss = ecdh(re, e.priv)\n    const ss = ecdh(this.repk, this.es)\n    // 4. ck, temp_k2 = hkdf(ck, ss)\n    const tempK2 = hkdf(ss, 64, this.ck)\n    this.ck = tempK2.subarray(0, 32)\n    this.tempK2 = tempK2.subarray(32)\n    // 5. c = encryptWithAd(temp_k2, 0, h, zero)\n    const c = ccpEncrypt(this.tempK2, Buffer.alloc(12), this.h, Buffer.alloc(0))\n    // 6. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 7. m = 0 || e.pub.compressed() Z|| c\n    const m = Buffer.concat([Buffer.alloc(1), this.epk, c])\n    return m\n  }\n  /**\n   * Receiver Act3 is the final phase in the authenticated key\n   * agreement. This act is executed only if act 2 was successful.\n   * The receiver extracts the public key of the initiator.\n   * @param m 66-byte message\n   */\n  public async receiveAct3(m: Buffer) {\n    // 1. read exactly 66 bytes from the network buffer\n    if (m.length !== 66) throw new Error('ACT3_READ_FAILED')\n    // 2. parse m into v, c, t\n    const v = m.subarray(0, 1)[0]\n    const c = m.subarray(1, 50)\n    const t = m.subarray(50)\n    // 3. validate v is recognized\n    if (v !== 0) throw new Error('ACT3_BAD_VERSION')\n    // 4. rs = decryptWithAD(temp_k2, 1, h, c)\n    const rs = ccpDecrypt(this.tempK2, Buffer.from('000000000100000000000000', 'hex'), this.h, c)\n    this.rpk = rs as Buffer\n    // 5. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 6. ss = ECDH(rs, e.priv)\n    const ss = ecdh(this.rpk, this.es)\n    // 7. ck, temp_k3 = hkdf(cs, ss)\n    const tempK3 = hkdf(ss, 64, this.ck)\n    this.ck = tempK3.subarray(0, 32)\n    this.tempK3 = tempK3.subarray(32)\n    // 8. p = decryptWithAD(temp_k3, 0, h, t)\n    ccpDecrypt(this.tempK3, Buffer.alloc(12), this.h, t)\n    // 9. rk, sk = hkdf(ck, zero)\n    const sk = hkdf(Buffer.alloc(0), 64, this.ck)\n    this.rk = sk.subarray(0, 32)\n    this.sk = sk.subarray(32)\n    // 10. rn = 0, sn = 0\n    this.rn = Buffer.alloc(12)\n    this.sn = Buffer.alloc(12)\n  }\n  /**\n   * Sends an encrypted message using the shared sending key and nonce.\n   * The nonce is rotated once the message is sent. The sending key is\n   * rotated every 1000 messages.\n   * @param m\n   */\n  public async encryptMessage(m: Buffer): Promise<Buffer> {\n    // step 1/2. serialize m length into int16\n    const l = Buffer.alloc(2)\n    l.writeUInt16BE(m.length, 0)\n    // step 3. encrypt l, using chachapoly1305, sn, sk)\n    const lc = ccpEncrypt(this.sk, this.sn, Buffer.alloc(0), l)\n    // step 3a: increment sn\n    if (this._incrementSendingNonce() >= 1000) this._rotateSendingKeys()\n    // step 4 encrypt m using chachapoly1305, sn, sk\n    const c = ccpEncrypt(this.sk, this.sn, Buffer.alloc(0), m)\n    // step 4a: increment sn\n    if (this._incrementSendingNonce() >= 1000) this._rotateSendingKeys()\n    // step 5 return m to be sent\n    return Buffer.concat([lc, c])\n  }\n  /**\n   * Decrypts the length of the message using the receiving key and nonce.\n   * The receiving key is rotated every 1000 messages.\n   */\n  public async decryptLength(lc: Buffer): Promise<number> {\n    const l = ccpDecrypt(this.rk, this.rn, Buffer.alloc(0), lc) as Buffer\n    if (this._incrementRecievingNonce() >= 1000) this._rotateRecievingKeys()\n    return l.readUInt16BE(0)\n  }\n  /**\n   * Decrypts the message using the receiving key and nonce. The receiving\n   * key is rotated every 1000 messages.\n   */\n  public async decryptMessage(c: Buffer) {\n    const m = ccpDecrypt(this.rk, this.rn, Buffer.alloc(0), c)\n    if (this._incrementRecievingNonce() >= 1000) this._rotateRecievingKeys()\n    return m as Buffer\n  }\n  /////////////////////////////////////\n  /**\n   * Initializes the noise state prior to Act1.\n   */\n  private async _initialize(pubkey: Buffer) {\n    // 1. h = SHA-256(protocolName)\n    this.h = await sha256(Buffer.from(this.protocolName))\n\n    // 2. ck = h\n    this.ck = this.h\n\n    // 3. h = SHA-256(h || prologue)\n    this.h = await sha256(Buffer.concat([this.h, this.prologue]))\n\n    // 4. h = SHA-256(h || pubkey)\n    this.h = await sha256(Buffer.concat([this.h, pubkey]))\n  }\n\n  private _incrementSendingNonce() {\n    const newValue = this.sn.readUInt16LE(4) + 1\n    this.sn.writeUInt16LE(newValue, 4)\n    return newValue\n  }\n\n  private _incrementRecievingNonce() {\n    const newValue = this.rn.readUInt16LE(4) + 1\n    this.rn.writeUInt16LE(newValue, 4)\n    return newValue\n  }\n\n  private _rotateSendingKeys() {\n    const result = hkdf(this.sk, 64, this.ck)\n    this.sk = result.subarray(32)\n    this.ck = result.subarray(0, 32)\n    this.sn = Buffer.alloc(12)\n  }\n\n  private _rotateRecievingKeys() {\n    const result = hkdf(this.rk, 64, this.ck)\n    this.rk = result.subarray(32)\n    this.ck = result.subarray(0, 32)\n    this.rn = Buffer.alloc(12)\n  }\n}\n","export type LnWebSocketOptions = {\n  /**\n   * 33-byte hex remote compressed public key.\n   * The identity of the node you would like to initiate a connection with\n   */\n  remoteNodePublicKey: string\n  /**\n   * The IP address of the remote node\n   */\n  ip: string\n  /**\n   * The port of the remote node. Defaults to 9735\n   */\n  port?: number\n  /**\n   * A WebSocket proxy endpoint for the browser to connect to,\n   * so that a server can create a direct connection to the node without the need for a tls certificate runnning on the remote node\n   * or if the Lightning node implementation does not support WebSocket connections directly\n   * Checkout https://github.com/clams-tech/lnsocket-proxy and https://github.com/jb55/ln-ws-proxy\n   */\n  wsProxy?: string\n  /**\n   * 32 byte hex encoded private key to be used as the local node secret.\n   * Use this to ensure a consistent local node identity across connection sessions\n   */\n  privateKey?: string\n  /**\n   Logger object to log info, warn, and error logs\n   */\n  logger?: Logger\n}\n\nexport type NoiseStateOptions = {\n  /**\n   * Local private key as a 32-byte buffer\n   */\n  ls: Buffer\n\n  /**\n   * Ephemeral private key as a 32-byte\n   */\n  es: Buffer\n}\n\n/**\n * Defined in BOLT01\n */\nexport enum MessageType {\n  // Setup and Control (0 - 31)\n  Init = 16,\n  Error = 17,\n  Ping = 18,\n  Pong = 19,\n\n  // Channel (32-127)\n  OpenChannel = 32,\n  AcceptChannel = 33,\n  FundingCreated = 34,\n  FundingSigned = 35,\n  FundingLocked = 36,\n  Shutdown = 38,\n  ClosingSigned = 39,\n\n  // Commitment (128-255)\n  //\n\n  // Routing (256-511)\n  ChannelAnnouncement = 256,\n  NodeAnnouncement = 257,\n  ChannelUpdate = 258,\n  AnnouncementSignatures = 259,\n  QueryShortChannelIds = 261,\n  ReplyShortChannelIdsEnd = 262,\n  QueryChannelRange = 263,\n  ReplyChannelRange = 264,\n  GossipTimestampFilter = 265,\n\n  CommandoRequest = 19535,\n  CommandoResponseContinues = 22859,\n  CommandoResponse = 22861\n}\n\n/**\n * States that the handshake process can be in. States depend on\n * whether the socket is the connection Initiator or Responder.\n *\n * Initiator:\n *   1.  create and send Iniatitor act1 and transition to\n *       AWAITING_RESPONDER_REPLY\n *   2.  process the Responder's reply as act2\n *   3.  create Initiator act3 reply to complete the handshake\n *       and transitions to READY\n *\n * Responder:\n *   1.  begins in AWAITING_INITIATOR waiting to receive act1\n *   2.  processes act1 and creates a reply as act2 and transitions\n *       to AWAITING_INITIATOR_REPLY\n *   3.  processes the Initiator's reply to complete the handshake\n *       and transition to READY\n */\nexport enum HANDSHAKE_STATE {\n  /**\n   * Initial state for the Initiator. Initiator will transition to\n   * AWAITING_RESPONDER_REPLY once act1 is completed and sent.\n   */\n  INITIATOR_INITIATING = 0,\n\n  /**\n   * Responders begin in this state and wait for the Intiator to begin\n   * the handshake. Sockets originating from the NoiseServer will\n   * begin in this state.\n   */\n  AWAITING_INITIATOR = 1,\n\n  /**\n   * Initiator has sent act1 and is awaiting the reply from the responder.\n   * Once received, the intiator will create the reply\n   */\n  AWAITING_RESPONDER_REPLY = 2,\n\n  /**\n   * Responder has  sent a reply to the inititator, the Responder will be\n   * waiting for the final stage of the handshake sent by the Initiator.\n   */\n  AWAITING_INITIATOR_REPLY = 3,\n\n  /**\n   * Responder/Initiator have completed the handshake and we're ready to\n   * start sending and receiving over the socket.\n   */\n  READY = 100\n}\n\nexport enum READ_STATE {\n  READY_FOR_LEN = 2,\n  READY_FOR_BODY = 3,\n  BLOCKED = 4\n}\n\nexport type JsonRpcRequest = {\n  /**The RPC method you would like to call*/\n  method: string\n  /**The params to for the above method.\n   * Can be an object with named parameters (like the -k options for the CLI)\n   * or an array of ordered params. If no value is passed in it defaults to an\n   * empty array\n   */\n  params?: unknown | unknown[]\n}\n\ntype JsonRpcBaseResponse = {\n  jsonrpc: string\n  id: string | number | null\n}\n\nexport type JsonRpcSuccessResponse = JsonRpcBaseResponse & { result: unknown }\n\nexport type JsonRpcErrorResponse = JsonRpcBaseResponse & {\n  error: { code: number; message: string; data?: unknown }\n}\n\nexport type CommandoRequest = JsonRpcRequest & {\n  /**Base64 encoded rune token as outputted by the commando-rune cli command\n   * If the rune does not have adequate permissions for this request an error will\n   * be returned\n   */\n  rune: string\n  /**Optional 8 byte hex encoded random string for matching the request to a response\n   * Lnmessage will handle this automatically, but in some instances it is handy to know the\n   * request id ahead of time\n   */\n  reqId?: string\n}\n\nexport type CommandoResponse = JsonRpcSuccessResponse | JsonRpcErrorResponse\n\nexport type Logger = {\n  info: (msg: string) => void\n  warn: (msg: string) => void\n  error: (msg: string) => void\n}\n","import { Buffer } from 'buffer'\n\n/**\n * BufferReader class is used to simplify reading information from a Buffer\n */\nexport class BufferReader {\n  /**\n   * Returns the number of bytes that will be used to encode\n   * a BigSize number. BigSize is defined in Lightning Network BOLT 07\n   */\n  public static bigSizeBytes(num: bigint): number {\n    if (num < BigInt(0xfd)) return 1\n    if (num < BigInt(0x10000)) return 3\n    if (num < BigInt(0x100000000)) return 5\n    else return 9\n  }\n\n  private _buffer: Buffer\n  private _position: number\n  private _lastReadBytes: number\n\n  /**\n   * Constructs a reader from the supplied Buffer\n   */\n  constructor(buffer: Buffer) {\n    this._buffer = buffer\n    this._position = 0\n    this._lastReadBytes = 0\n  }\n\n  /**\n   * Gets or sets the current position of the cursor in the buffer\n   */\n  public get position(): number {\n    return this._position\n  }\n\n  public set position(val: number) {\n    this._position = val\n  }\n\n  /**\n   * Gets if the cursor is at the end of file.\n   */\n  public get eof(): boolean {\n    return this._position === this._buffer.length\n  }\n\n  /**\n   * Gets the underlying buffer that the cursor\n   * is reading from.\n   */\n  public get buffer(): Buffer {\n    return this._buffer\n  }\n\n  /**\n   * Number of bytes read in last operation executed on the cursor.\n   * Especially useful for operations that return variable length of\n   * results such as readBytes or readVarUint.\n   */\n  public get lastReadBytes(): number {\n    return this._lastReadBytes\n  }\n\n  /**\n   * Read a UInt8 number\n   */\n  public readUInt8(): number {\n    return this._readStandard(this.readUInt8.name, 1)\n  }\n\n  /**\n   * Read a UInt16 number as little-endian\n   */\n  public readUInt16LE(): number {\n    return this._readStandard(this.readUInt16LE.name, 2)\n  }\n\n  /**\n   * Read a UInt16 number as big-endian\n   */\n  public readUInt16BE(): number {\n    return this._readStandard(this.readUInt16BE.name, 2)\n  }\n\n  /**\n   * Read a UInt32 number as little-endian\n   */\n  public readUInt32LE(): number {\n    return this._readStandard(this.readUInt32LE.name, 4)\n  }\n\n  /**\n   * Read a UInt32 number as big-endian\n   */\n  public readUInt32BE(): number {\n    return this._readStandard(this.readUInt32BE.name, 4)\n  }\n\n  /**\n   * Read a UInt64 number as big-endian\n   */\n  public readUInt64BE(): bigint {\n    return BigInt('0x' + this.readBytes(8).toString('hex'))\n  }\n\n  /**\n   * Read a UInt64 number as little-endian\n   */\n  public readUInt64LE(): bigint {\n    return BigInt('0x' + this.readBytes(8).reverse().toString('hex'))\n  }\n\n  /**\n   * Reads a variable length unsigned integer as specified in the protocol\n   * documentation and aways returns a BN to maintain a consistant call\n   * signature.\n   *\n   * @remarks\n   * Specified in:\n   * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\n   *\n   * Reads the first byte and determines the length of the remaining integer.\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public readVarUint(): bigint | void {\n    const size = this.readUInt8()\n    if (size < 0xfd) {\n      this._lastReadBytes = 1\n      return BigInt(size)\n    }\n    switch (size) {\n      case 0xfd:\n        this._lastReadBytes = 3\n        return BigInt(this.readUInt16LE())\n      case 0xfe:\n        this._lastReadBytes = 5\n        return BigInt(this.readUInt32LE())\n      case 0xff:\n        this._lastReadBytes = 9\n        return this.readUInt64LE()\n    }\n  }\n\n  /**\n   * Reads a variable length unsigned integer as specified in the Lightning Network\n   * protocol documentation and always returns a BigInt to maintain a consistent\n   * call signature.\n   *\n   * @remarks\n   * Specified in:\n   * https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#appendix-a-bigsize-test-vectors\n   *\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public readBigSize(): bigint {\n    const size = this.readUInt8()\n\n    if (size < 0xfd) {\n      this._lastReadBytes = 1\n      return BigInt(size)\n    }\n    switch (size) {\n      case 0xfd: {\n        this._lastReadBytes = 3\n        const val = this.readUInt16BE()\n        if (val < 0xfd) throw new Error('decoded varint is not canonical')\n        return BigInt(val)\n      }\n      case 0xfe: {\n        this._lastReadBytes = 5\n        const val = this.readUInt32BE()\n        if (val < 0x10000) throw new Error('decoded varint is not canonical')\n        return BigInt(val)\n      }\n      case 0xff: {\n        this._lastReadBytes = 9\n        const val = this.readUInt64BE()\n        if (val < BigInt(0x100000000)) throw new Error('decoded varint is not canonical')\n        return val\n      }\n      default:\n        throw new Error(`Unrecognised size: ${size} when trying to read BigSize`)\n    }\n  }\n\n  /**\n   * Read bytes from the buffer into a new Buffer. Unlike the default\n   * slice method, the values do not point to the same memory location\n   * as the source buffer. The values are copied to a new buffer.\n   *\n   * @param len optional number of bytes to read, returns\n   * all remaining bytes when omitted\n   */\n  public readBytes(len?: number): Buffer {\n    if (len === 0) {\n      this._lastReadBytes = 0\n      return Buffer.alloc(0)\n    } else if (typeof len === 'number' && len > 0) {\n      if (this._position + len > this._buffer.length) {\n        throw new RangeError('Index out of range')\n      }\n      const slice = this._buffer.subarray(this._position, this._position + len)\n      const result = Buffer.alloc(slice.length, slice)\n      this._position += len\n      this._lastReadBytes = len\n      return result\n    } else {\n      if (this._position === this._buffer.length) {\n        this._lastReadBytes = 0\n        return Buffer.alloc(0)\n      }\n      const slice = this._buffer.subarray(this._position)\n      const result = Buffer.alloc(slice.length, slice)\n      this._position = this._buffer.length\n      this._lastReadBytes = result.length\n      return result\n    }\n  }\n\n  /**\n   * Reads bytes from the buffer at the current position without\n   * moving the cursor.\n   * @param len optional number of bytes to read\n   */\n  public peakBytes(len?: number): Buffer {\n    if (len === 0) {\n      return Buffer.alloc(0)\n    } else if (typeof len === 'number' && len > 0) {\n      if (this._position + len > this._buffer.length) {\n        throw new RangeError('Index out of range')\n      }\n      const slice = this._buffer.subarray(this._position, this._position + len)\n      const result = Buffer.alloc(slice.length, slice)\n      return result\n    } else {\n      if (this._position === this._buffer.length) throw new RangeError('Index out of range')\n      const slice = this._buffer.subarray(this._position)\n      const result = Buffer.alloc(slice.length, slice)\n      return result\n    }\n  }\n\n  /**\n   * TLV 0 to 2 byte unsigned integer encoded in big-endian.\n   */\n  public readTUInt16(): number {\n    const size = Math.min(2, this._buffer.length - this._position)\n    if (size === 0) return 0\n    const val = this._buffer.readUIntBE(this._position, size)\n    this._assertMinimalTUInt(BigInt(val), size)\n    this._position += size\n    return val\n  }\n\n  /**\n   * TLV 0 to 4 byte unsigned integer encoded in big-endian.\n   */\n  public readTUInt32(): number {\n    const size = Math.min(4, this._buffer.length - this._position)\n    if (size === 0) return 0\n    const val = this._buffer.readUIntBE(this._position, size)\n    this._assertMinimalTUInt(BigInt(val), size)\n    this._position += size\n    return val\n  }\n\n  /**\n   * TLV 0 to 8 byte unsigned integer encoded in big-endian.\n   */\n  public readTUInt64(): bigint {\n    const size = Math.min(8, this._buffer.length - this._position)\n    if (size === 0) return BigInt(0)\n    const hex = this._buffer.subarray(this._position, this._position + size).toString('hex') || '0'\n    const val = BigInt('0x' + hex)\n    this._assertMinimalTUInt(val, size)\n    this._position += size\n    return val\n  }\n\n  /**\n   * Helper for reading off buffer using built-in read functions\n   * @param fn name of function\n   * @param len length to read\n   */\n  private _readStandard(fn: string, len: number): number {\n    if (this._position + len > this._buffer.length) {\n      throw new RangeError('Index out of range')\n    }\n\n    // @ts-ignore\n    const result: number = this._buffer[fn](this._position)\n    this._position += len\n    this._lastReadBytes = len\n    return result\n  }\n\n  /**\n   * Ensures the TUInt value is minimally encoded\n   * @param num\n   * @param bytes\n   */\n  private _assertMinimalTUInt(num: bigint, bytes: number) {\n    const msg = 'TUInt not minimal'\n    for (let i = 0; i < 9; i++) {\n      if (num < BigInt('0x1' + ''.padStart(i * 2, '0'))) {\n        if (bytes !== i) {\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Utility class for writing arbitrary data into a Buffer. This class will\n * automatically expand the underlying Buffer and return a trimmed view\n * when complete.\n */\nexport class BufferWriter {\n  private _position: number\n  private _fixed: boolean\n  private _buffer: Buffer\n\n  /**\n   * Constructs a BufferWriter that can optionally wrap an existing Buffer.\n   * If no buffer is provided, the BufferWriter will internally manage an\n   * exponentially growing Buffer to allow writing of data of an unknown size.\n   *\n   * If a Buffer is provided, writing that would overflow will throw an\n   * exception.\n   * @param buffer\n   */\n  constructor(buffer?: Buffer) {\n    this._position = 0\n    this._fixed = !!buffer\n    this._buffer = buffer || Buffer.alloc(0)\n  }\n\n  /**\n   * Gets the current size of the output Buffer\n   */\n  public get size(): number {\n    return this._position\n  }\n\n  /**\n   * Returns the Buffer which will be either the full Buffer if this was a\n   * fixed Buffer or will be the expandable Buffer sliced to the current\n   * position\n   */\n  public toBuffer(): Buffer {\n    if (this._fixed) return this._buffer\n    else return this._buffer.subarray(0, this._position)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt8(val: number) {\n    this._writeStandard(this.writeUInt8.name, val, 1)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt16LE(val: number) {\n    this._writeStandard(this.writeUInt16LE.name, val, 2)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt16BE(val: number) {\n    this._writeStandard(this.writeUInt16BE.name, val, 2)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt32LE(val: number) {\n    this._writeStandard(this.writeUInt32LE.name, val, 4)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt32BE(val: number) {\n    this._writeStandard(this.writeUInt32BE.name, val, 4)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param value\n   */\n  public writeUInt64LE(value: number | bigint) {\n    const val = BigInt(value)\n    if (val < 0 || val >= BigInt(2) ** BigInt(64)) {\n      throw new RangeError(\n        `The value of \"value\" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${value.toString()}`\n      )\n    }\n    const buf = Buffer.from(val.toString(16).padStart(16, '0'), 'hex')\n    this.writeBytes(buf.reverse())\n  }\n\n  /**\n   * Write at the current positiion\n   * @param value\n   */\n  public writeUInt64BE(value: number | bigint) {\n    const val = BigInt(value)\n    if (val < 0 || val >= BigInt(2) ** BigInt(64)) {\n      throw new RangeError(\n        `The value of \"value\" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${value.toString()}`\n      )\n    }\n    const buf = Buffer.from(val.toString(16).padStart(16, '0'), 'hex')\n    this.writeBytes(buf)\n  }\n\n  /**\n   * Write bytes at the current positiion\n   * @param buffer\n   */\n  public writeBytes(buffer: Buffer) {\n    if (!buffer || !buffer.length) return\n    this._expand(buffer.length)\n    buffer.copy(this._buffer, this._position)\n    this._position += buffer.length\n  }\n\n  /**\n   * Reads a variable length unsigned integer in little-endian as specified in\n   * the Bitcoin protocol documentation.\n   *\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public writeVarInt(val: bigint | number) {\n    const num = BigInt(val)\n    if (num < BigInt(0xfd)) {\n      this.writeUInt8(Number(num))\n    } else if (num < BigInt(0x10000)) {\n      this.writeUInt8(0xfd)\n      this.writeUInt16LE(Number(num))\n    } else if (num < BigInt(0x100000000)) {\n      this.writeUInt8(0xfe)\n      this.writeUInt32LE(Number(num))\n    } else {\n      this.writeUInt8(0xff)\n      this.writeUInt64LE(num)\n    }\n  }\n\n  /**\n   * Reads a variable length unsigned integer as specified in the Lightning Network\n   * protocol documentation and always returns a BigInt to maintain a consistent\n   * call signature.\n   *\n   * @remarks\n   * Specified in:\n   * https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#appendix-a-bigsize-test-vectors\n   *\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public writeBigSize(val: bigint | number) {\n    const num = BigInt(val)\n    if (num < BigInt(0xfd)) {\n      this.writeUInt8(Number(num))\n    } else if (num < BigInt(0x10000)) {\n      this.writeUInt8(0xfd)\n      this.writeUInt16BE(Number(num))\n    } else if (num < BigInt(0x100000000)) {\n      this.writeUInt8(0xfe)\n      this.writeUInt32BE(Number(num))\n    } else {\n      this.writeUInt8(0xff)\n      this.writeUInt64BE(num)\n    }\n  }\n\n  /**\n   * TLV 0 to 2 byte unsigned integer encoded in big-endian.\n   * @param val\n   */\n  public writeTUInt16(val: number) {\n    if (val === 0) return\n    const size = val > 0xff ? 2 : 1\n    this._expand(size)\n    this._buffer.writeUIntBE(val, this._position, size)\n    this._position += size\n  }\n\n  /**\n   * TLV 0 to 4 byte unsigned integer encoded in big-endian.\n   */\n  public writeTUInt32(val: number) {\n    if (val === 0) return\n    const size = val > 0xffffff ? 4 : val > 0xffff ? 3 : val > 0xff ? 2 : 1\n    this._expand(size)\n    this._buffer.writeUIntBE(val, this._position, size)\n    this._position += size\n  }\n\n  /**\n   * TLV 0 to 8 byte unsigned integer encoded in big-endian.\n   */\n  public writeTUInt64(val: bigint) {\n    if (val === BigInt(0)) return\n    let valString = val.toString(16)\n    if (valString.length % 2 === 1) valString = '0' + valString\n    const buf = Buffer.from(valString, 'hex')\n    this.writeBytes(buf)\n  }\n\n  /**\n   * Expands the underlying buffer as needed by doubling the size of the\n   * Buffer when it needs to grow.\n   * @param needed\n   */\n  private _expand(needed: number) {\n    const required = this._position + needed\n\n    // Ensure that a fixed Buffer length is not violated\n    if (this._fixed && required > this._buffer.length) {\n      throw new RangeError('Out of range')\n    }\n\n    // expand the buffer if the current buffer is insufficiently lengthed\n    if (this._buffer.length < required) {\n      // calculate the new length based on the required length and some\n      // maths where we determine the number of bytes required and at the\n      // next power of 2.\n      const newLen = 1 << Math.ceil(Math.log2(required))\n      const newBuf = Buffer.alloc(newLen)\n\n      // copy the old data to the new buffer and then dispose of the old\n      // buffer\n      this._buffer.copy(newBuf)\n      this._buffer = newBuf\n    }\n  }\n\n  /**\n   * Helper for writing to the buffer using built-in write\n   * functions\n   * @param fn name of function\n   * @param val number to write\n   * @param len length of number in bytes\n   */\n  private _writeStandard(fn: string, val: number, len: number) {\n    this._expand(len)\n    // @ts-ignore\n    this._buffer[fn](val, this._position)\n    this._position += len\n  }\n}\n","import * as bigintutil from './BigIntUtils'\nimport { Buffer } from 'buffer'\n\ntype BigIntInput = string | number | bigint | boolean\n\n/**\n * BitField assists with using bit flags to set or unset values in the bit\n * field. Preferrably a flag type is provided, otherwise it defaults to allow\n * arbitrary setting of integers corresponding to a particular bit index.\n *\n * Internally, values are stored as bigint so that more than 32 values\n * can be used since there is a limit of 31 digits that can be manipulated\n * using bitwise operations in JavaScript.\n */\nexport class BitField<T = number> {\n  /**\n   * Constructs a bitmask from a number\n   */\n  public static fromNumber(value: number) {\n    return new BitField(BigInt(value))\n  }\n\n  /**\n   * Constructs a bitmask from a buffer\n   */\n  public static fromBuffer(value: Buffer) {\n    if (value.length === 0) return new BitField()\n    return new BitField(BigInt('0x' + value.toString('hex')))\n  }\n\n  public value: bigint\n\n  constructor(value?: bigint) {\n    this.value = value || BigInt(0)\n  }\n\n  public isSet(bit: BigIntInput): boolean {\n    return (this.value & (BigInt(1) << BigInt(bit))) > BigInt(0)\n  }\n\n  public set(bit: BigIntInput) {\n    this.value |= BigInt(1) << BigInt(bit)\n  }\n\n  public unset(bit: BigIntInput) {\n    this.value &= ~(this.value & (BigInt(1) << BigInt(bit)))\n  }\n\n  public toggle(bit: BigIntInput) {\n    this.value ^= BigInt(1) << BigInt(bit)\n  }\n\n  /**\n   * Returns the full list of set flags for the bit field\n   */\n  public flags(): T[] {\n    const bits: T[] = []\n    let bit = 0\n    let val = 1n\n    while (val < this.value) {\n      if (this.value & val) bits.push(bit as any)\n      bit += 1\n      val <<= 1n\n    }\n    return bits\n  }\n\n  /**\n   * Returns the index of the most-significant bit that is set\n   */\n  public msb(): number {\n    let num = this.value\n    let bit = 0\n    while (num > 1) {\n      num = num >> 1n\n      bit += 1\n    }\n    return bit\n  }\n\n  /**\n   * Returns a new BitField with the bitwise AND of the two BitFields\n   * @param bitfield\n   */\n  public and(bitfield: BitField): BitField {\n    return new BitField(this.value & bitfield.value)\n  }\n\n  /**\n   * Returns a new BitField with the bitwise OR of the two BitFields\n   * @param bitfield\n   */\n  public or(bitfield: BitField): BitField {\n    return new BitField(this.value | bitfield.value)\n  }\n\n  /**\n   * Returns a new BitField with the bitwise XOR of the two BitFields\n   * @param bitfield\n   */\n  public xor(bitfield: BitField): BitField {\n    return new BitField(this.value ^ bitfield.value)\n  }\n\n  public toBigInt() {\n    return this.value\n  }\n\n  public toNumber() {\n    return Number(this.value)\n  }\n\n  public toBuffer(): Buffer {\n    if (this.value === BigInt(0)) return Buffer.alloc(0)\n    return bigintutil.bigintToBuffer(this.value)\n  }\n}\n","import { Buffer } from 'buffer'\n\nexport function calcBytes(num: bigint) {\n  let b = 0\n  while (num > BigInt(0)) {\n    b += 1\n    num /= BigInt(2 ** 8)\n  }\n  return b\n}\n\nexport function bigintToBuffer(num: bigint): Buffer {\n  const bytes = calcBytes(num)\n  return Buffer.from(num.toString(16).padStart(bytes * 2, '0'), 'hex')\n}\n","import { Buffer } from 'buffer'\nimport { BufferReader, BufferWriter } from './buf'\nimport { BitField } from './BitField'\nimport { InitFeatureFlags } from './InitFeatureFlags'\nimport { MessageType } from '../types'\nimport { readTlvs } from './read-tlvs'\nimport { IWireMessage } from './IWireMessage'\n\n/**\n * InitMessage is defined in BOLT #1. Once authentication is complete, the first\n * message reveals the features supported or required by the node sending the\n * message. This message is sent even on a reconnection.\n *\n * This message contains two fields; global features and local features, that\n * are used to signal how the message should operate. The values of are defined\n * in the BOLT #9.\n */\nexport class InitMessage implements IWireMessage {\n  /**\n   * Processes a buffer containing the message information. This method\n   * will capture the arbitrary length global and local\n   * features into two internal properties of the newly constructed\n   * init message object.\n   */\n  public static deserialize(buffer: Buffer): InitMessage {\n    const instance = new InitMessage()\n    const reader = new BufferReader(buffer)\n\n    // read the type bytes\n    reader.readUInt16BE()\n\n    // read the global features and per the specification, the global\n    // features should not exceed features greater than 13.\n    const gflen = reader.readUInt16BE()\n    const gf = BitField.fromBuffer(reader.readBytes(gflen))\n\n    // Read the local length and parse into a BN value.\n    const lflen = reader.readUInt16BE()\n    const lf = BitField.fromBuffer(reader.readBytes(lflen))\n\n    // construct a single features object by bitwise or of the global and\n    // local features.\n    instance.features = new BitField().or(gf).or(lf)\n\n    // process TLVs\n    readTlvs(reader, (type: bigint, valueReader: BufferReader) => {\n      switch (type) {\n        // Process networks TLVs which is a series of chain_hash 32\n        // byte values. This method will simply read from the stream\n        // until every thing has been read\n        case BigInt(1): {\n          while (!valueReader.eof) {\n            const chainHash = valueReader.readBytes(32)\n            instance.chainHashes.push(chainHash)\n          }\n          return true\n        }\n        default:\n          return false\n      }\n    })\n\n    return instance\n  }\n\n  /**\n   * Message type 16\n   */\n  public type: MessageType = MessageType.Init\n\n  /**\n   * BitField containing the features provided in by the local or remote node\n   */\n  public features: BitField<InitFeatureFlags> = new BitField()\n\n  /**\n   * Supported chain_hashes for the remote peer\n   */\n  public chainHashes: Buffer[] = []\n\n  /**\n   * Serialize will construct a properly formatted message based on the\n   * properties of the configured message.\n   */\n  public serialize() {\n    const writer = new BufferWriter()\n\n    // write the type\n    writer.writeUInt16BE(this.type)\n\n    // write gflen\n    const gflen = 0\n    writer.writeUInt16BE(gflen)\n\n    // write features\n    const features = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])\n    const featuresLen = features.length\n    writer.writeUInt16BE(featuresLen)\n    writer.writeBytes(features)\n\n    // write chainhash tlv\n    if (this.chainHashes.length) {\n      writer.writeBigSize(1) // type\n      writer.writeBigSize(this.chainHashes.length * 32) // length\n      writer.writeBytes(Buffer.concat(this.chainHashes)) // value\n    }\n\n    return writer.toBuffer()\n  }\n}\n","import { BufferReader } from './buf'\n\n/**\n * Reads TLVs from a reader until the entire stream is processed. The handler is\n * responsible for doing something with the data bytes.\n * @param reader\n * @param handler\n */\nexport function readTlvs(\n  reader: BufferReader,\n  handler: (type: bigint, value: BufferReader) => boolean\n) {\n  let lastType: bigint = BigInt(-1)\n\n  while (!reader.eof) {\n    try {\n      const type = reader.readBigSize()\n      const len = reader.readBigSize()\n      const value = reader.readBytes(Number(len))\n      const valueReader = new BufferReader(value)\n\n      if (type <= lastType) {\n        throw new Error('Invalid TLV stream')\n      }\n\n      const isEven = type % BigInt(2) === BigInt(0)\n      const wasHandled = handler(type, valueReader)\n\n      if (!wasHandled && isEven) {\n        throw new Error('Unknown even type')\n      }\n\n      if (wasHandled && !valueReader.eof) {\n        throw new Error('Non-canonical length')\n      }\n\n      lastType = type\n    } catch (error) {\n      // tried to read an index out of range\n    }\n  }\n}\n","import { Buffer } from 'buffer'\nimport { BufferReader, BufferWriter } from './buf'\nimport { MessageType } from '../types'\nimport { IWireMessage } from './IWireMessage'\n\nexport const PONG_BYTE_THRESHOLD = 65532\n\n/**\n * In order to allow for the existence of long-lived TCP\n * connections,  at times it may be required that both ends keep\n * alive the TCP connection at the application level.\n *\n * The ping message is sent by an initiator and includes a value\n * for the number of pong bytes it expects to receive as\n * a reply. The ignored bits should be set to 0.\n */\nexport class PingMessage implements IWireMessage {\n  /**\n   * Deserialize a message and return a new instance of the\n   * PingMessage type.\n   */\n  public static deserialize(payload: Buffer): PingMessage {\n    const cursor = new BufferReader(payload)\n    cursor.readUInt16BE()\n\n    const instance = new PingMessage()\n    instance.numPongBytes = cursor.readUInt16BE()\n\n    const bytesLength = cursor.readUInt16BE()\n\n    instance.ignored = cursor.readBytes(bytesLength)\n    return instance\n  }\n\n  /**\n   * Ping message type is 18\n   */\n  public type: MessageType = MessageType.Ping\n\n  /**\n   * The number of bytes that should be returned in the pong message.\n   * Can be set to 65532 to indicate that no pong message should be\n   * sent. Setting to any number below 65532 will require a pong\n   * matching the corresponding number of bytes. If the reply\n   * byteslen does not match this, you may terminate the channels\n   * with the client.\n   */\n  public numPongBytes: number = 1\n\n  /**\n   * Should set ignored to 0s. Must not set ignored to\n   * sensitive data such as secrets or portions of initialized\n   * memory.\n   */\n  public ignored: Buffer = Buffer.alloc(0)\n\n  /**\n   * Serialize the PingMessage and return a Buffer\n   */\n  public serialize(): Buffer {\n    const len =\n      2 + // type\n      2 + // num_pong_bytes\n      2 + // byteslen\n      this.ignored.length\n\n    const br = new BufferWriter(Buffer.alloc(len))\n    br.writeUInt16BE(this.type)\n    br.writeUInt16BE(this.numPongBytes)\n    br.writeUInt16BE(this.ignored.length)\n    br.writeBytes(this.ignored)\n    return br.toBuffer()\n  }\n\n  /**\n   * triggersReply indicates if a pong message must send a reply.\n   * Ping messages than are smaller than 65532 must send a reply\n   * with the corresponding number of bytes. Above this value\n   * no reply is necessary.  Refer to BOLT #1.\n   */\n  public get triggersReply(): boolean {\n    return this.numPongBytes < PONG_BYTE_THRESHOLD\n  }\n}\n","import { Buffer } from 'buffer'\nimport { BufferReader, BufferWriter } from './buf'\nimport { MessageType } from '../types'\nimport { IWireMessage } from './IWireMessage'\n\nexport class PongMessage implements IWireMessage {\n  /**\n   * Deserializes a pong message from a Buffer into a PongMessage\n   * instance.\n   */\n  public static deserialize(payload: Buffer): PongMessage {\n    const instance = new PongMessage()\n\n    const reader = new BufferReader(payload)\n    reader.readUInt16BE() // read off type\n\n    const byteslen = reader.readUInt16BE()\n    instance.ignored = reader.readBytes(byteslen)\n    return instance\n  }\n\n  /**\n   * Message type = 19\n   */\n  public type: MessageType = MessageType.Pong\n\n  /**\n   * Should be set to zeros of length specified in a ping message's\n   * num_pong_bytes. Must not set ignored to sensitive data such as\n   * secrets or portions of initialized memory.\n   */\n  public ignored: Buffer\n\n  /**\n   * In order to allow for the existence of long-lived TCP\n   * connections, at times it may be required that both ends keep\n   * alive the TCP connection at the application level.\n   *\n   * The pong message is a reply to a ping message and must\n   * reply with the specify number of bytes when the num_pong_bytes\n   * value is less than 65532.\n   * for the number of pong bytes it expects to receive as\n   * a reply. The ignored bits should be set to 0.\n   */\n  constructor(numPongBytes = 0) {\n    this.ignored = Buffer.alloc(numPongBytes)\n  }\n\n  /**\n   * Serializes a PongMessage into a Buffer that can be\n   * streamed on the wire.\n   */\n  public serialize(): Buffer {\n    const len =\n      2 + // type\n      2 + // byteslen\n      +this.ignored.length\n\n    const writer = new BufferWriter(Buffer.alloc(len))\n    writer.writeUInt16BE(this.type)\n    writer.writeUInt16BE(this.ignored.length)\n    writer.writeBytes(this.ignored)\n    return writer.toBuffer()\n  }\n}\n","import { BufferReader } from './buf'\nimport { CommandoResponse, JsonRpcErrorResponse, MessageType } from '../types'\n\nexport class CommandoMessage {\n  /**\n   * Processes a buffer containing the message information. This method\n   * will capture the id of the commando response as well as the payload\n   */\n  public static deserialize(buffer: Buffer): CommandoMessage {\n    const instance = new CommandoMessage()\n    const reader = new BufferReader(buffer)\n\n    // read the type bytes\n    reader.readUInt16BE()\n\n    instance.id = reader.readBytes(8).toString('hex')\n    const json = reader.readBytes(buffer.byteLength - 26).toString()\n\n    try {\n      instance.response = JSON.parse(json)\n    } catch (error) {\n      instance.response = {\n        jsonrpc: '2.0',\n        id: null,\n        error: { code: 1, message: 'Could not parse json response' }\n      } as JsonRpcErrorResponse\n    }\n\n    return instance\n  }\n\n  public type: MessageType = MessageType.CommandoResponse\n  public id: string\n  public response: CommandoResponse\n}\n","import { BehaviorSubject, firstValueFrom, Observable, Subject } from 'rxjs'\nimport { filter, map, skip } from 'rxjs/operators'\nimport { Buffer } from 'buffer'\nimport { createRandomPrivateKey } from './crypto.js'\nimport { NoiseState } from './noise-state.js'\nimport { validateInit } from './validation.js'\nimport { deserialize } from './messages/MessageFactory.js'\nimport { IWireMessage } from './messages/IWireMessage.js'\nimport { BufferReader, BufferWriter } from './messages/buf.js'\nimport { CommandoMessage } from './messages/CommandoMessage.js'\nimport { PongMessage } from './messages/PongMessage.js'\nimport { PingMessage } from './messages/PingMessage.js'\n\nimport {\n  LnWebSocketOptions,\n  HANDSHAKE_STATE,\n  READ_STATE,\n  MessageType,\n  JsonRpcRequest,\n  JsonRpcSuccessResponse,\n  JsonRpcErrorResponse,\n  Logger,\n  CommandoRequest\n} from './types'\n\nconst DEFAULT_RECONNECT_ATTEMPTS = 5\n\nclass LnMessage {\n  /**The underlying Noise protocol. Can be used if you want to play around with the low level Lightning transport protocol*/\n  public noise: NoiseState\n  /**The public key of the node that Lnmessage is connected to*/\n  public remoteNodePublicKey: string\n  /**The public key Lnmessage uses when connecting to a remote node\n   * If you passed in a private key when initialising,\n   * this public key will be derived from it and can be used for persistent identity\n   * across session connections\n   */\n  public publicKey: string\n  /**The private key that was either passed in on init or generated automatically\n   * Reuse this when reconnecting for persistent id\n   */\n  public privateKey: string\n  /**The url that the WebSocket will connect to. It uses the wsProxy option if provided\n   * or otherwise will initiate a WebSocket connection directly to the node\n   */\n  public wsUrl: string\n  /**The WebSocket instance*/\n  public socket: WebSocket | null\n  /**Observable for subscribing to connection/disconnection*/\n  public connected$: BehaviorSubject<boolean>\n  /**Boolean indicating whether currently connecting or not*/\n  public connecting: boolean\n  /**Observable stream of decypted messages. This can be used to extend Lnmessage\n   * functionality so that it can handle other Lightning message types\n   */\n  public decryptedMsgs$: Observable<Buffer>\n  /**Obserable stream of all commando response messages*/\n  public commandoMsgs$: Observable<\n    (JsonRpcSuccessResponse | JsonRpcErrorResponse) & { reqId: string }\n  >\n  /**Node JS Buffer instance, useful if handling decrypted messages manually*/\n  public Buffer: BufferConstructor\n\n  private _ls: Buffer\n  private _es: Buffer\n  private _handshakeState: HANDSHAKE_STATE\n  private _readState: READ_STATE\n  private _decryptedMsgs$: Subject<Buffer>\n  private _commandoMsgs$: Subject<CommandoMessage>\n  private _partialCommandoMsgs: Record<string, Buffer>\n  private _attemptedReconnects: number\n  private _logger: Logger | void\n  private _attemptReconnect: boolean\n  private _messageBuffer: BufferReader\n  private _processingBuffer: boolean\n  private _l: number | null\n\n  constructor(options: LnWebSocketOptions) {\n    validateInit(options)\n\n    const { remoteNodePublicKey, wsProxy, privateKey, ip, port = 9735, logger } = options\n\n    this._ls = Buffer.from(privateKey || createRandomPrivateKey(), 'hex')\n    this._es = Buffer.from(createRandomPrivateKey(), 'hex')\n\n    this.noise = new NoiseState({\n      ls: this._ls,\n      es: this._es\n    })\n\n    this.remoteNodePublicKey = remoteNodePublicKey\n    this.publicKey = this.noise.lpk.toString('hex')\n    this.privateKey = this._ls.toString('hex')\n    this.wsUrl = wsProxy ? `${wsProxy}/${ip}:${port}` : `wss://${remoteNodePublicKey}@${ip}:${port}`\n    this.connected$ = new BehaviorSubject<boolean>(false)\n    this.connecting = false\n    this.Buffer = Buffer\n\n    this._handshakeState = HANDSHAKE_STATE.INITIATOR_INITIATING\n    this._decryptedMsgs$ = new Subject()\n    this.decryptedMsgs$ = this._decryptedMsgs$.asObservable()\n    this._commandoMsgs$ = new Subject()\n    this.commandoMsgs$ = this._commandoMsgs$\n      .asObservable()\n      .pipe(map(({ response, id }) => ({ ...response, reqId: id })))\n\n    this._partialCommandoMsgs = {}\n    this._attemptedReconnects = 0\n    this._logger = logger\n    this._readState = READ_STATE.READY_FOR_LEN\n    this._processingBuffer = false\n    this._l = null\n\n    this.decryptedMsgs$.subscribe((msg) => {\n      this.handleDecryptedMessage(msg)\n    })\n  }\n\n  async connect(attemptReconnect = true): Promise<boolean> {\n    if (this.connected$.getValue()) {\n      return true\n    }\n\n    this.connecting = true\n    this._log('info', `Initiating connection to node ${this.remoteNodePublicKey}`)\n    this._attemptReconnect = attemptReconnect\n    this._attemptedReconnects += 1\n    this.socket = new WebSocket(this.wsUrl)\n    this.socket.binaryType = 'arraybuffer'\n\n    this.socket.onopen = async () => {\n      this._log('info', 'WebSocket is connected')\n      this._log('info', 'Creating Act1 message')\n      const msg = await this.noise.initiatorAct1(Buffer.from(this.remoteNodePublicKey, 'hex'))\n\n      if (this.socket) {\n        this._log('info', 'Sending Act1 message')\n        this.socket.send(msg)\n        this._handshakeState = HANDSHAKE_STATE.AWAITING_RESPONDER_REPLY\n      }\n    }\n\n    this.socket.onclose = async () => {\n      this._log('error', 'WebSocket is closed')\n      this._log('info', `Attempted reconnects: ${this._attemptedReconnects}`)\n\n      this.connected$.next(false)\n\n      if (this._attemptReconnect && this._attemptedReconnects < DEFAULT_RECONNECT_ATTEMPTS) {\n        this.connecting = true\n        this._log('info', 'Waiting to reconnect')\n        await new Promise((resolve) => setTimeout(resolve, (this._attemptedReconnects || 1) * 1000))\n        this.connect()\n      }\n    }\n\n    this.socket.onerror = (err) => {\n      this._log('error', `WebSocket error: ${JSON.stringify(err)}`)\n    }\n\n    this.socket.onmessage = this.queueMessage.bind(this)\n\n    return firstValueFrom(this.connected$.pipe(skip(1)))\n  }\n\n  private queueMessage(event: MessageEvent) {\n    const { data } = event as { data: ArrayBuffer }\n    const message = Buffer.from(data)\n\n    const currentData =\n      this._messageBuffer && !this._messageBuffer.eof && this._messageBuffer.readBytes()\n\n    this._messageBuffer = new BufferReader(\n      currentData ? Buffer.concat([currentData, message]) : message\n    )\n\n    if (!this._processingBuffer) {\n      this._processingBuffer = true\n      this._processBuffer()\n    }\n  }\n\n  disconnect() {\n    this._log('info', 'Manually disconnecting from WebSocket')\n\n    // reset noise state\n    this.noise = new NoiseState({\n      ls: this._ls,\n      es: this._es\n    })\n\n    this._attemptReconnect = false\n    this.socket && this.socket.close()\n  }\n\n  private async _processBuffer() {\n    try {\n      // Loop while there was still data to process on the process\n      // buffer.\n      let readMore = true\n      do {\n        if (this._handshakeState !== HANDSHAKE_STATE.READY) {\n          switch (this._handshakeState) {\n            // Initiator received data before initialized\n            case HANDSHAKE_STATE.INITIATOR_INITIATING:\n              throw new Error('Received data before intialised')\n\n            // Initiator Act2\n            case HANDSHAKE_STATE.AWAITING_RESPONDER_REPLY:\n              readMore = await this._processResponderReply()\n              break\n          }\n        } else {\n          switch (this._readState) {\n            case READ_STATE.READY_FOR_LEN:\n              readMore = await this._processPacketLength()\n              break\n            case READ_STATE.READY_FOR_BODY:\n              readMore = await this._processPacketBody()\n              break\n            case READ_STATE.BLOCKED:\n              readMore = false\n              break\n            default:\n              throw new Error('Unknown read state')\n          }\n        }\n      } while (readMore)\n    } catch (err) {\n      // Terminate on failures as we won't be able to recovery\n      // since the noise state has rotated nonce and we won't\n      // be able to any more data without additional errors.\n      this.disconnect()\n    }\n\n    this._processingBuffer = false\n  }\n\n  private async _processResponderReply() {\n    // read 50 bytes\n    const data = this._messageBuffer.readBytes(50)\n\n    if (data.byteLength !== 50) {\n      throw new Error('Invalid message received from remote node')\n    }\n\n    // process reply\n    this._log('info', 'Validating message as part of Act2')\n    await this.noise.initiatorAct2(data)\n\n    // create final act of the handshake\n    this._log('info', 'Creating reply for Act3')\n    const reply = await this.noise.initiatorAct3()\n\n    if (this.socket) {\n      this._log('info', 'Sending reply for act3')\n      // send final handshake\n      this.socket.send(reply)\n\n      // transition\n      this._handshakeState = HANDSHAKE_STATE.READY\n    }\n\n    // return true to continue processing\n    return true\n  }\n\n  private async _processPacketLength() {\n    const LEN_CIPHER_BYTES = 2\n    const LEN_MAC_BYTES = 16\n\n    try {\n      // Try to read the length cipher bytes and the length MAC bytes\n      // If we cannot read the 18 bytes, the attempt to process the\n      // message will abort.\n      const lc = this._messageBuffer.readBytes(LEN_CIPHER_BYTES + LEN_MAC_BYTES)\n      if (!lc) return false\n\n      // Decrypt the length including the MAC\n      const l = await this.noise.decryptLength(lc)\n\n      // We need to store the value in a local variable in case\n      // we are unable to read the message body in its entirety.\n      // This allows us to skip the length read and prevents\n      // nonce issues since we've already decrypted the length.\n      this._l = l\n\n      // Transition state\n      this._readState = READ_STATE.READY_FOR_BODY\n\n      // return true to continue reading\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  private async _processPacketBody() {\n    const MESSAGE_MAC_BYTES = 16\n\n    if (!this._l) return false\n\n    try {\n      // With the length, we can attempt to read the message plus\n      // the MAC for the message. If we are unable to read because\n      // there is not enough data in the read buffer, we need to\n      // store l. We are not able to simply unshift it becuase we\n      // have already rotated the keys.\n      const c = this._messageBuffer.readBytes(this._l + MESSAGE_MAC_BYTES)\n      if (!c) return false\n\n      // Decrypt the full message cipher + MAC\n      const m = await this.noise.decryptMessage(c)\n\n      // Now that we've read the message, we can remove the\n      // cached length before we transition states\n      this._l = null\n\n      // Push the message onto the read buffer for the consumer to\n      // read. We are mindful of slow reads by the consumer and\n      // will respect backpressure signals.\n      this._decryptedMsgs$.next(m)\n      this._readState = READ_STATE.READY_FOR_LEN\n\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  async handleDecryptedMessage(decrypted: Buffer) {\n    try {\n      const reader = new BufferReader(decrypted)\n      const type = reader.readUInt16BE()\n      const [typeName] = Object.entries(MessageType).find(([name, val]) => val === type) || []\n      const requestId = reader.readBytes(8).toString('hex')\n      const message = reader.readBytes()\n\n      this._log('info', `Message type is: ${typeName || 'unknown'}`)\n\n      if (type === MessageType.CommandoResponseContinues) {\n        this._log(\n          'info',\n          'Received a partial commando message, caching it to join with other parts'\n        )\n\n        this._partialCommandoMsgs[requestId] = this._partialCommandoMsgs[requestId]\n          ? Buffer.concat([\n              this._partialCommandoMsgs[requestId],\n              message.subarray(0, message.byteLength - 16)\n            ])\n          : decrypted.subarray(0, decrypted.length - 16)\n\n        return\n      }\n\n      if (type === MessageType.CommandoResponse && this._partialCommandoMsgs[requestId]) {\n        this._log(\n          'info',\n          'Received a final commando msg and we have a partial message to join it to. Joining now'\n        )\n\n        // join commando msg chunks\n        decrypted = Buffer.concat([this._partialCommandoMsgs[requestId], message])\n        delete this._partialCommandoMsgs[requestId]\n      }\n\n      // deserialise\n      this._log('info', 'Deserialising payload')\n      const payload = deserialize(decrypted)\n\n      switch (payload.type) {\n        case MessageType.Init: {\n          this._log('info', 'Constructing Init message reply')\n          const reply = await this.noise.encryptMessage((payload as IWireMessage).serialize())\n\n          if (this.socket) {\n            this._log('info', 'Sending Init message reply')\n            this.socket.send(reply)\n            this._log('info', 'Connected and ready to send messages!')\n            this.connected$.next(true)\n            this.connecting = false\n            this._attemptedReconnects = 0\n          }\n\n          break\n        }\n\n        case MessageType.Ping: {\n          this._log('info', 'Received a Ping message')\n          this._log('info', 'Creating a Pong message')\n          const pongMessage = new PongMessage((payload as PingMessage).numPongBytes).serialize()\n          const pong = await this.noise.encryptMessage(pongMessage)\n\n          if (this.socket) {\n            this._log('info', 'Sending a Pong message')\n            this.socket.send(pong)\n          }\n\n          break\n        }\n\n        case MessageType.CommandoResponse: {\n          this._commandoMsgs$.next(payload as CommandoMessage)\n        }\n\n        // ignore all other messages\n      }\n    } catch (error) {\n      this._log('error', `Error handling incoming message: ${(error as Error).message}`)\n    }\n  }\n\n  async commando({\n    method,\n    params = [],\n    rune,\n    reqId\n  }: CommandoRequest): Promise<JsonRpcSuccessResponse['result']> {\n    this._log('info', `Commando request method: ${method} params: ${JSON.stringify(params)}`)\n\n    // not connected and not initiating a connection currently\n    if (!this.connected$.getValue() && !this.connecting) {\n      this._log('info', 'No socket connection, so creating one now')\n      await this.connect()\n    } else {\n      this._log('info', 'Ensuring we have a connection before making request')\n      // ensure that we are connected before making any requests\n      await firstValueFrom(this.connected$.pipe(filter((connected) => connected === true)))\n    }\n\n    const writer = new BufferWriter()\n\n    if (!reqId) {\n      // create random id to match request with response\n      const idBytes = Buffer.allocUnsafe(8)\n      const id = window.crypto.getRandomValues(idBytes)\n      reqId = id.toString('hex')\n    }\n\n    // write the type\n    writer.writeUInt16BE(MessageType.CommandoRequest)\n\n    // write the id\n    writer.writeBytes(Buffer.from(reqId, 'hex'))\n\n    // write the request\n    writer.writeBytes(\n      Buffer.from(\n        JSON.stringify({\n          rune,\n          method,\n          params\n        })\n      )\n    )\n\n    this._log('info', 'Creating message to send')\n    const message = await this.noise.encryptMessage(writer.toBuffer())\n\n    if (this.socket) {\n      this._log('info', 'Sending commando message')\n      this.socket.send(message)\n\n      this._log('info', 'Message sent and awaiting response')\n      const { response } = await firstValueFrom(\n        this._commandoMsgs$.pipe(filter((commandoMsg) => commandoMsg.id === reqId))\n      )\n\n      const { result } = response as JsonRpcSuccessResponse\n      const { error } = response as JsonRpcErrorResponse\n      this._log(\n        'info',\n        result ? 'Successful response received' : `Error response received: ${error.message}`\n      )\n\n      if (error) throw error\n\n      return result\n    } else {\n      throw new Error('No socket initialised and connected')\n    }\n  }\n\n  _log(level: keyof Logger, msg: string) {\n    if (this._logger && this._logger[level]) {\n      this._logger[level](`[${level.toUpperCase()} - ${new Date().toLocaleTimeString()}]: ${msg}`)\n    }\n  }\n}\n\nexport default LnMessage\n","import { validPrivateKey, validPublicKey } from './crypto.js'\nimport { LnWebSocketOptions, Logger } from './types'\n\nexport function validateInit(options: LnWebSocketOptions): void {\n  const { remoteNodePublicKey, wsProxy, privateKey, ip, port, logger } = options\n\n  if (!remoteNodePublicKey || !validPublicKey(remoteNodePublicKey)) {\n    throw new Error(`${remoteNodePublicKey} is not a valid public key`)\n  }\n\n  const ipRegex = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)(\\.(?!$)|$)){4}$/\n\n  if (!ip || !ip.match(ipRegex)) {\n    throw new Error(`${ip} is not a valid IP address`)\n  }\n\n  if (!port || port < 1 || port > 65535) {\n    throw new Error(`${port} is not a valid port number`)\n  }\n\n  if (wsProxy) {\n    const errMsg = `${wsProxy} is not a valid url`\n    try {\n      const url = new URL(wsProxy)\n      if (url.protocol !== 'wss:' && url.protocol !== 'ws:') {\n        throw new Error(errMsg)\n      }\n    } catch (err) {\n      throw new Error(errMsg)\n    }\n  }\n\n  if (privateKey && !validPrivateKey(privateKey)) {\n    throw new Error(`${privateKey} is not a valid private key`)\n  }\n\n  if (logger) {\n    if (typeof logger !== 'object') {\n      throw new Error('Logger must be of type object')\n    }\n\n    const validLevels = ['info', 'warn', 'error']\n\n    Object.entries(logger).forEach(([level, handler]) => {\n      if (!validLevels.includes(level)) {\n        throw new Error(`Invalid logger level: ${level}`)\n      }\n\n      if (typeof handler !== 'function') {\n        throw new Error(`Logger for level: ${level} is not a function`)\n      }\n    })\n  }\n}\n","import { IWireMessage } from './IWireMessage.js'\nimport { InitMessage } from './InitMessage.js'\nimport { PingMessage } from './PingMessage.js'\nimport { PongMessage } from './PongMessage.js'\nimport { CommandoMessage } from './CommandoMessage.js'\nimport { MessageType } from '../types'\n\nexport function deserialize(buffer: Buffer): IWireMessage | { type: number } {\n  const type = buffer.readUInt16BE(0)\n\n  switch (type) {\n    case MessageType.Init:\n      return InitMessage.deserialize(buffer)\n    case MessageType.Ping:\n      return PingMessage.deserialize(buffer)\n    case MessageType.Pong:\n      return PongMessage.deserialize(buffer)\n    case MessageType.CommandoResponse:\n    case MessageType.CommandoResponseContinues:\n      return CommandoMessage.deserialize(buffer)\n  }\n\n  return { type }\n}\n"],"names":["ROTATE","v","c","Buffer","from","Chacha20","key","nonce","this","input","cachePos","buffer","output","Uint32Array","constants","readUInt32LE","_proto","prototype","quarterRound","a","b","d","x","makeBlock","start","i","writeUInt32LE","Error","getBytes","len","dpos","dst","cacheLen","copy","Poly1305","leftover","r","h","pad","finished","Uint16Array","t","readUInt16LE","blocks","m","mpos","bytes","hibit","j","update","length","want","finish","mac","g","mask","f","writeUInt16LE","Cipher","iv","decrypt","alen","clen","chacha","poly","tag","_decrypt","_hasData","setAAD","aad","padding","padAmount","fill","data","inputEnc","outputEnc","outData","_update","toString","_final","chunk","lens","out","Math","min","xorTest","getAuthTag","setAuthTag","rem","sha256","Promise","resolve","window","crypto","subtle","digest","then","res","e","reject","ecdh","pubkey","privkey","secp256k1","hmacHash","CryptoJS","HmacSHA256","enc","Hex","parse","stringify","words","ikm","salt","info","alloc","ceil","prk","byteLength","n","tp","bi","push","concat","slice","subarray","privKey","compressed","publicKeyCreate","ccpEncrypt","k","ad","plaintext","cipher","ccpDecrypt","ciphertext","decipher","createRandomPrivateKey","allocUnsafe","getRandomValues","validPrivateKey","privateKey","privateKeyVerify","READ_STATE","NoiseState","_ref","ls","es","protocolName","prologue","lpk","epk","rpk","repk","ck","rk","sk","sn","rn","tempK1","tempK2","tempK3","getPublicKey","initiatorAct1","_this2","_initialize","_sha","hkdf","_sha2","initiatorAct2","_this4","re","_sha3","_sha4","initiatorAct3","_this6","_sha5","receiveAct1","_this8","_sha6","_sha7","recieveAct2","_this10","_sha8","_sha9","receiveAct3","_this12","rs","_sha10","encryptMessage","_this14","l","writeUInt16BE","lc","_incrementSendingNonce","_rotateSendingKeys","decryptLength","_this16","_incrementRecievingNonce","_rotateRecievingKeys","readUInt16BE","decryptMessage","_this18","_this20","_sha11","_sha12","newValue","result","BufferReader","bigSizeBytes","_buffer","_position","_lastReadBytes","num","BigInt","readUInt8","_readStandard","name","readUInt32BE","readUInt64BE","readBytes","readUInt64LE","reverse","readVarUint","size","readBigSize","val","_val","_val2","RangeError","_slice","_result","peakBytes","readTUInt16","readUIntBE","_assertMinimalTUInt","readTUInt32","readTUInt64","hex","fn","padStart","_createClass","get","set","BufferWriter","_fixed","toBuffer","_proto2","writeUInt8","_writeStandard","writeUInt32BE","writeUInt64LE","value","pow","buf","writeBytes","writeUInt64BE","_expand","writeVarInt","Number","writeBigSize","writeTUInt16","writeUIntBE","writeTUInt32","writeTUInt64","valString","needed","required","newLen","log2","newBuf","BitField","fromNumber","fromBuffer","isSet","bit","unset","toggle","flags","bits","msb","and","bitfield","or","xor","toBigInt","toNumber","calcBytes","bigintToBuffer","MessageType","HANDSHAKE_STATE","InitMessage","type","Init","features","chainHashes","deserialize","instance","reader","gflen","gf","lflen","lf","readTlvs","handler","lastType","eof","valueReader","isEven","wasHandled","error","chainHash","serialize","writer","PingMessage","Ping","numPongBytes","ignored","payload","cursor","bytesLength","br","PongMessage","Pong","byteslen","CommandoMessage","CommandoResponse","id","response","json","JSON","jsonrpc","code","message","_settle","pact","state","s","_Pact","o","bind","observer","onFulfilled","callback","_this","onRejected","_isSettledPact","thenable","options","noise","remoteNodePublicKey","publicKey","wsUrl","socket","connected$","connecting","decryptedMsgs$","commandoMsgs$","_ls","_es","_handshakeState","_readState","_decryptedMsgs$","_commandoMsgs$","_partialCommandoMsgs","_attemptedReconnects","_logger","_attemptReconnect","_messageBuffer","_processingBuffer","_l","wsProxy","ip","port","logger","publicKeyVerify","match","errMsg","url","URL","protocol","err","validLevels","Object","entries","forEach","level","includes","validateInit","_options$port","BehaviorSubject","INITIATOR_INITIATING","asObservable","Subject","pipe","map","_extends","reqId","READY_FOR_LEN","subscribe","msg","handleDecryptedMessage","connect","attemptReconnect","_this3","getValue","_log","binaryType","onopen","send","AWAITING_RESPONDER_REPLY","onclose","next","_temp2","onerror","onmessage","queueMessage","firstValueFrom","skip","event","currentData","_processBuffer","disconnect","close","_temp5","_result5","_interrupt3","_this5","_temp6","_catch","readMore","body","test","awaitBody","shouldContinue","_resumeAfterBody","_resumeAfterTest","_do","READY","_switch","_processResponderReply","_this4$_processRespon","_processPacketLength","_this4$_processPacket","READY_FOR_BODY","_processPacketBody","BLOCKED","_this7","reply","LEN_CIPHER_BYTES","decrypted","typeName","find","_ref3","CommandoResponseContinues","requestId","pongMessage","pong","_temp7","commando","method","_ref5","params","_ref5$params","rune","idBytes","CommandoRequest","filter","commandoMsg","_ref4","_temp11","connected","toUpperCase","Date","toLocaleTimeString"],"mappings":"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"}