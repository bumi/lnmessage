{"version":3,"file":"index.modern.js","sources":["../src/chacha/chacha20.ts","../src/chacha/poly1305.ts","../src/chacha/index.ts","../src/crypto.ts","../src/noise-state.ts","../src/messages/buf.ts","../src/messages/BitField.ts","../src/messages/BigIntUtils.ts","../src/types.ts","../src/messages/InitMessage.ts","../src/messages/read-tlvs.ts","../src/messages/PingMessage.ts","../src/messages/PongMessage.ts","../src/messages/CommandoMessage.ts","../src/index.ts","../src/validation.ts","../src/messages/MessageFactory.ts"],"sourcesContent":["import { Buffer } from 'buffer'\n\nfunction ROTATE(v: number, c: number) {\n  return (v << c) | (v >>> (32 - c))\n}\n\nconst constants = Buffer.from('expand 32-byte k')\n\nclass Chacha20 {\n  public input: Uint32Array\n  public cachePos: number\n  public buffer: Uint32Array\n  public output: Buffer\n\n  constructor(key: Buffer, nonce: Buffer) {\n    this.input = new Uint32Array(16)\n\n    // https://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-01#section-2.3\n    this.input[0] = constants.readUInt32LE(0)\n    this.input[1] = constants.readUInt32LE(4)\n    this.input[2] = constants.readUInt32LE(8)\n    this.input[3] = constants.readUInt32LE(12)\n    this.input[4] = key.readUInt32LE(0)\n    this.input[5] = key.readUInt32LE(4)\n    this.input[6] = key.readUInt32LE(8)\n    this.input[7] = key.readUInt32LE(12)\n    this.input[8] = key.readUInt32LE(16)\n    this.input[9] = key.readUInt32LE(20)\n    this.input[10] = key.readUInt32LE(24)\n    this.input[11] = key.readUInt32LE(28)\n\n    this.input[12] = 0\n\n    this.input[13] = nonce.readUInt32LE(0)\n    this.input[14] = nonce.readUInt32LE(4)\n    this.input[15] = nonce.readUInt32LE(8)\n\n    this.cachePos = 64\n    this.buffer = new Uint32Array(16)\n    this.output = new Buffer(64)\n  }\n\n  quarterRound(a: number, b: number, c: number, d: number) {\n    const x = this.buffer\n    x[a] += x[b]\n    x[d] = ROTATE(x[d] ^ x[a], 16)\n    x[c] += x[d]\n    x[b] = ROTATE(x[b] ^ x[c], 12)\n    x[a] += x[b]\n    x[d] = ROTATE(x[d] ^ x[a], 8)\n    x[c] += x[d]\n    x[b] = ROTATE(x[b] ^ x[c], 7)\n  }\n\n  makeBlock(output: Buffer, start: number) {\n    let i = -1\n    // copy input into working buffer\n    while (++i < 16) {\n      this.buffer[i] = this.input[i]\n    }\n    i = -1\n    while (++i < 10) {\n      // straight round\n      this.quarterRound(0, 4, 8, 12)\n      this.quarterRound(1, 5, 9, 13)\n      this.quarterRound(2, 6, 10, 14)\n      this.quarterRound(3, 7, 11, 15)\n\n      //diaganle round\n      this.quarterRound(0, 5, 10, 15)\n      this.quarterRound(1, 6, 11, 12)\n      this.quarterRound(2, 7, 8, 13)\n      this.quarterRound(3, 4, 9, 14)\n    }\n\n    i = -1\n\n    // copy working buffer into output\n    while (++i < 16) {\n      this.buffer[i] += this.input[i]\n      output.writeUInt32LE(this.buffer[i], start)\n      start += 4\n    }\n\n    this.input[12]++\n\n    if (!this.input[12]) {\n      throw new Error('counter is exausted')\n    }\n  }\n\n  getBytes(len: number) {\n    let dpos = 0\n    const dst = new Buffer(len)\n    const cacheLen = 64 - this.cachePos\n\n    if (cacheLen) {\n      if (cacheLen >= len) {\n        this.output.copy(dst, 0, this.cachePos, 64)\n        this.cachePos += len\n        return dst\n      } else {\n        this.output.copy(dst, 0, this.cachePos, 64)\n        len -= cacheLen\n        dpos += cacheLen\n        this.cachePos = 64\n      }\n    }\n\n    while (len > 0) {\n      if (len <= 64) {\n        this.makeBlock(this.output, 0)\n        this.output.copy(dst, dpos, 0, len)\n        if (len < 64) {\n          this.cachePos = len\n        }\n        return dst\n      } else {\n        this.makeBlock(dst, dpos)\n      }\n      len -= 64\n      dpos += 64\n    }\n\n    throw new Error('something bad happended')\n  }\n}\n\nexport default Chacha20\n","import { Buffer } from 'buffer'\n\nclass Poly1305 {\n  public buffer: Buffer\n  public leftover: number\n  public r: Uint16Array\n  public h: Uint16Array\n  public pad: Uint16Array\n  public finished: number\n\n  constructor(key: Buffer) {\n    this.buffer = new Buffer(16)\n    this.leftover = 0\n    this.r = new Uint16Array(10)\n    this.h = new Uint16Array(10)\n    this.pad = new Uint16Array(8)\n    this.finished = 0\n\n    let t = new Uint16Array(8),\n      i\n\n    for (i = 8; i--; ) t[i] = key.readUInt16LE(i * 2)\n\n    this.r[0] = t[0] & 0x1fff\n    this.r[1] = ((t[0] >>> 13) | (t[1] << 3)) & 0x1fff\n    this.r[2] = ((t[1] >>> 10) | (t[2] << 6)) & 0x1f03\n    this.r[3] = ((t[2] >>> 7) | (t[3] << 9)) & 0x1fff\n    this.r[4] = ((t[3] >>> 4) | (t[4] << 12)) & 0x00ff\n    this.r[5] = (t[4] >>> 1) & 0x1ffe\n    this.r[6] = ((t[4] >>> 14) | (t[5] << 2)) & 0x1fff\n    this.r[7] = ((t[5] >>> 11) | (t[6] << 5)) & 0x1f81\n    this.r[8] = ((t[6] >>> 8) | (t[7] << 8)) & 0x1fff\n    this.r[9] = (t[7] >>> 5) & 0x007f\n\n    for (i = 8; i--; ) {\n      this.h[i] = 0\n      this.pad[i] = key.readUInt16LE(16 + 2 * i)\n    }\n    this.h[8] = 0\n    this.h[9] = 0\n    this.leftover = 0\n    this.finished = 0\n  }\n\n  blocks(m: Buffer, mpos: number, bytes: number) {\n    const hibit = this.finished ? 0 : 1 << 11\n    let t = new Uint16Array(8),\n      d = new Uint32Array(10),\n      c = 0,\n      i = 0,\n      j = 0\n\n    while (bytes >= 16) {\n      for (i = 8; i--; ) t[i] = m.readUInt16LE(i * 2 + mpos)\n\n      this.h[0] += t[0] & 0x1fff\n      this.h[1] += ((t[0] >>> 13) | (t[1] << 3)) & 0x1fff\n      this.h[2] += ((t[1] >>> 10) | (t[2] << 6)) & 0x1fff\n      this.h[3] += ((t[2] >>> 7) | (t[3] << 9)) & 0x1fff\n      this.h[4] += ((t[3] >>> 4) | (t[4] << 12)) & 0x1fff\n      this.h[5] += (t[4] >>> 1) & 0x1fff\n      this.h[6] += ((t[4] >>> 14) | (t[5] << 2)) & 0x1fff\n      this.h[7] += ((t[5] >>> 11) | (t[6] << 5)) & 0x1fff\n      this.h[8] += ((t[6] >>> 8) | (t[7] << 8)) & 0x1fff\n      this.h[9] += (t[7] >>> 5) | hibit\n\n      for (i = 0, c = 0; i < 10; i++) {\n        d[i] = c\n        for (j = 0; j < 10; j++) {\n          d[i] += (this.h[j] & 0xffffffff) * (j <= i ? this.r[i - j] : 5 * this.r[i + 10 - j])\n          if (j === 4) {\n            c = d[i] >>> 13\n            d[i] &= 0x1fff\n          }\n        }\n        c += d[i] >>> 13\n        d[i] &= 0x1fff\n      }\n      c = (c << 2) + c\n      c += d[0]\n      d[0] = c & 0xffff & 0x1fff\n      c = c >>> 13\n      d[1] += c\n\n      for (i = 10; i--; ) this.h[i] = d[i]\n\n      mpos += 16\n      bytes -= 16\n    }\n  }\n\n  update(m: Buffer) {\n    let bytes = m.length\n    let want = 0,\n      i = 0,\n      mpos = 0\n\n    if (this.leftover) {\n      want = 16 - this.leftover\n      if (want > bytes) want = bytes\n      for (i = want; i--; ) {\n        this.buffer[this.leftover + i] = m[i + mpos]\n      }\n      bytes -= want\n      mpos += want\n      this.leftover += want\n      if (this.leftover < 16) return this\n      this.blocks(this.buffer, 0, 16)\n      this.leftover = 0\n    }\n\n    if (bytes >= 16) {\n      want = bytes & ~(16 - 1)\n      this.blocks(m, mpos, want)\n      mpos += want\n      bytes -= want\n    }\n\n    if (bytes) {\n      for (i = bytes; i--; ) {\n        this.buffer[this.leftover + i] = m[i + mpos]\n      }\n      this.leftover += bytes\n    }\n    return this\n  }\n\n  finish() {\n    let mac = new Buffer(16),\n      g = new Uint16Array(10),\n      c = 0,\n      mask = 0,\n      f = 0,\n      i = 0\n    if (this.leftover) {\n      i = this.leftover\n      this.buffer[i++] = 1\n      for (; i < 16; i++) {\n        this.buffer[i] = 0\n      }\n      this.finished = 1\n      this.blocks(this.buffer, 0, 16)\n    }\n\n    c = this.h[1] >>> 13\n    this.h[1] &= 0x1fff\n    for (i = 2; i < 10; i++) {\n      this.h[i] += c\n      c = this.h[i] >>> 13\n      this.h[i] &= 0x1fff\n    }\n    this.h[0] += c * 5\n    c = this.h[0] >>> 13\n    this.h[0] &= 0x1fff\n    this.h[1] += c\n    c = this.h[1] >>> 13\n    this.h[1] &= 0x1fff\n    this.h[2] += c\n\n    g[0] = this.h[0] + 5\n    c = g[0] >>> 13\n    g[0] &= 0x1fff\n    for (i = 1; i < 10; i++) {\n      g[i] = this.h[i] + c\n      c = g[i] >>> 13\n      g[i] &= 0x1fff\n    }\n    g[9] -= 1 << 13\n\n    mask = (g[9] >>> 15) - 1\n    for (i = 10; i--; ) g[i] &= mask\n    mask = ~mask\n    for (i = 10; i--; ) {\n      this.h[i] = (this.h[i] & mask) | g[i]\n    }\n\n    this.h[0] = this.h[0] | (this.h[1] << 13)\n    this.h[1] = (this.h[1] >> 3) | (this.h[2] << 10)\n    this.h[2] = (this.h[2] >> 6) | (this.h[3] << 7)\n    this.h[3] = (this.h[3] >> 9) | (this.h[4] << 4)\n    this.h[4] = (this.h[4] >> 12) | (this.h[5] << 1) | (this.h[6] << 14)\n    this.h[5] = (this.h[6] >> 2) | (this.h[7] << 11)\n    this.h[6] = (this.h[7] >> 5) | (this.h[8] << 8)\n    this.h[7] = (this.h[8] >> 8) | (this.h[9] << 5)\n\n    f = (this.h[0] & 0xffffffff) + this.pad[0]\n    this.h[0] = f\n    for (i = 1; i < 8; i++) {\n      f = (this.h[i] & 0xffffffff) + this.pad[i] + (f >>> 16)\n      this.h[i] = f\n    }\n\n    for (i = 8; i--; ) {\n      mac.writeUInt16LE(this.h[i], i * 2)\n      this.pad[i] = 0\n    }\n    for (i = 10; i--; ) {\n      this.h[i] = 0\n      this.r[i] = 0\n    }\n\n    return mac\n  }\n}\n\nexport default Poly1305\n","import { Buffer } from 'buffer'\nimport Chacha20 from './chacha20.js'\nimport Poly1305 from './poly1305.js'\n\nclass Cipher {\n  private alen: number\n  private clen: number\n  private chacha: Chacha20\n  private poly: Poly1305\n  private tag: null | Buffer\n  private _decrypt: boolean\n  private _hasData: boolean\n\n  constructor(key: Buffer, iv: Buffer, decrypt: boolean = false) {\n    this.alen = 0\n    this.clen = 0\n    this.chacha = new Chacha20(key, iv)\n    this.poly = new Poly1305(this.chacha.getBytes(64))\n    this.tag = null\n    this._decrypt = decrypt\n    this._hasData = false\n  }\n\n  setAAD(aad: Buffer) {\n    if (this._hasData) {\n      throw new Error('Attempting to set AAD in unsupported state')\n    }\n    this.alen = aad.length\n    this.poly.update(aad)\n    const padding = new Buffer(padAmount(this.alen))\n    if (padding.length) {\n      padding.fill(0)\n      this.poly.update(padding)\n    }\n  }\n\n  update(data: string | Buffer, inputEnc?: BufferEncoding, outputEnc?: BufferEncoding) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data, inputEnc)\n    }\n\n    let outData = this._update(data) || Buffer.from('')\n\n    return outputEnc ? outData.toString(outputEnc) : outData\n  }\n\n  final(outputEnc?: BufferEncoding) {\n    let outData = this._final() || Buffer.from('')\n\n    return outputEnc ? outData.toString(outputEnc) : outData\n  }\n\n  _update(chunk: Buffer) {\n    if (!this._hasData) {\n      this._hasData = true\n    }\n\n    const len = chunk.length\n\n    if (!len) {\n      return\n    }\n\n    this.clen += len\n    const pad = this.chacha.getBytes(len)\n\n    let i = -1\n    while (++i < len) {\n      pad[i] ^= chunk[i]\n    }\n\n    if (this._decrypt) {\n      this.poly.update(chunk)\n    } else {\n      this.poly.update(pad)\n    }\n\n    return pad\n  }\n\n  _final() {\n    if (this._decrypt && !this.tag) {\n      throw new Error('Unsupported state or unable to authenticate data')\n    }\n\n    const padding = new Buffer(padAmount(this.clen))\n\n    if (padding.length) {\n      padding.fill(0)\n      this.poly.update(padding)\n    }\n\n    const lens = new Buffer(16)\n    lens.fill(0)\n    lens.writeUInt32LE(this.alen, 0)\n    lens.writeUInt32LE(this.clen, 8)\n\n    const tag = this.poly.update(lens).finish()\n\n    if (this._decrypt) {\n      if (xorTest(tag, this.tag as Buffer)) {\n        throw new Error('Unsupported state or unable to authenticate data')\n      }\n    } else {\n      this.tag = tag\n    }\n\n    return tag\n  }\n\n  getAuthTag() {\n    if (this._decrypt || this.tag === null) {\n      return new Buffer('')\n    }\n    return this.tag\n  }\n\n  setAuthTag(tag: Buffer) {\n    if (this._decrypt) {\n      this.tag = tag\n    } else {\n      throw new Error('Attempting to set auth tag in unsupported state')\n    }\n  }\n}\n\nfunction padAmount(len: number) {\n  const rem = len % 16\n  return rem ? 16 - rem : 0\n}\n\nfunction xorTest(a: Buffer, b: Buffer) {\n  let out = 0\n\n  if (a.length !== b.length) {\n    out++\n  }\n\n  const len = Math.min(a.length, b.length)\n\n  let i = -1\n  while (++i < len) {\n    out += a[i] ^ b[i]\n  }\n\n  return out\n}\n\nexport function createDecipher(key: Buffer, iv: Buffer) {\n  return new Cipher(key, iv, true)\n}\n\nexport function createCipher(key: Buffer, iv: Buffer) {\n  return new Cipher(key, iv)\n}\n","import CryptoJS from 'crypto-js'\nimport { Buffer } from 'buffer'\nimport secp256k1 from 'secp256k1'\nimport { createCipher, createDecipher } from './chacha/index.js'\n\nexport function ecdh(pubkey: Uint8Array, privkey: Uint8Array) {\n  return Buffer.from(secp256k1.ecdh(pubkey, privkey))\n}\n\nexport function hmacHash(key: Buffer, input: Buffer) {\n  const words = CryptoJS.HmacSHA256(\n    CryptoJS.enc.Hex.parse(input.toString('hex')),\n    CryptoJS.enc.Hex.parse(key.toString('hex'))\n  )\n\n  return Buffer.from(CryptoJS.enc.Hex.stringify(words), 'hex')\n}\n\nexport async function sha256(input: Buffer): Promise<Buffer> {\n  const res = await window.crypto.subtle.digest('SHA-256', input)\n  return Buffer.from(res)\n}\n\nexport function hkdf(ikm: Buffer, len: number, salt = Buffer.alloc(0), info = Buffer.alloc(0)) {\n  // extract step\n  const prk = hmacHash(salt, ikm)\n\n  // expand\n  const n = Math.ceil(len / prk.byteLength)\n  if (n > 255) throw new Error('Output length exceeds maximum')\n\n  const t = [Buffer.alloc(0)]\n\n  for (let i = 1; i <= n; i++) {\n    const tp = t[t.length - 1]\n    const bi = Buffer.from([i])\n    t.push(hmacHash(prk, Buffer.concat([tp, info, bi])))\n  }\n\n  return Buffer.concat(t.slice(1)).subarray(0, len)\n}\n\nexport function getPublicKey(privKey: Buffer, compressed = true) {\n  return Buffer.from(secp256k1.publicKeyCreate(privKey, compressed))\n}\n\n/**\n * Encrypt data using authenticated encryption with associated data (AEAD)\n * ChaCha20-Poly1305.\n *\n * @param k private key, 64-bytes\n * @param n nonce, 12-bytes\n * @param ad associated data\n * @param plaintext raw data to encrypt\n * @returns encrypted data + tag as a variable length buffer\n */\nexport function ccpEncrypt(k: Buffer, n: Buffer, ad: Buffer, plaintext: Buffer): Buffer {\n  const cipher = createCipher(k, n)\n  cipher.setAAD(ad)\n\n  const pad = cipher.update(plaintext) as Buffer\n\n  cipher.final && cipher.final()\n  const tag = cipher.getAuthTag()\n  return Buffer.concat([pad, tag])\n}\n\n/**\n * Decrypt data uusing authenticated encryption with associated data (AEAD)\n * ChaCha20-Poly1305\n *\n * @param k private key, 64-bytes\n * @param n nonce, 12-bytes\n * @param ad associated data, variable length\n * @param ciphertext encrypted data to decrypt\n * @returns decrypteed data as a variable length Buffer\n */\nexport function ccpDecrypt(k: Buffer, n: Buffer, ad: Buffer, ciphertext: Buffer) {\n  const decipher = createDecipher(k, n)\n\n  decipher.setAAD(ad)\n\n  if (ciphertext.length === 16) {\n    decipher.setAuthTag(ciphertext)\n    return decipher.final()\n  }\n\n  if (ciphertext.length > 16) {\n    const tag = ciphertext.subarray(ciphertext.length - 16)\n    const pad = ciphertext.subarray(0, ciphertext.length - 16)\n    decipher.setAuthTag(tag)\n    let m = decipher.update(pad)\n    const f = decipher.final()\n    m = Buffer.concat([m as Buffer, f as Buffer])\n    return m\n  }\n}\n\nexport function createRandomPrivateKey(): string {\n  let privKey\n  do {\n    const bytes = Buffer.allocUnsafe(32)\n    privKey = window.crypto.getRandomValues(bytes)\n  } while (!validPrivateKey(privKey))\n\n  return privKey.toString('hex')\n}\n\nexport function validPublicKey(publicKey: string): boolean {\n  return secp256k1.publicKeyVerify(Buffer.from(publicKey, 'hex'))\n}\n\nexport function validPrivateKey(privateKey: string | Buffer): boolean {\n  return secp256k1.privateKeyVerify(\n    typeof privateKey === 'string' ? Buffer.from(privateKey, 'hex') : privateKey\n  )\n}\n","import { ccpDecrypt, ccpEncrypt, ecdh, getPublicKey, hkdf, sha256 } from './crypto.js'\nimport type { NoiseStateOptions } from './types'\nimport { Buffer } from 'buffer'\n\nexport class NoiseState {\n  /**\n   * The official protocol name for the Lightning variant of Noise. This\n   * value is mixed into the iniitialiization function to start the\n   * handshake.\n   */\n  public protocolName = Buffer.from('Noise_XK_secp256k1_ChaChaPoly_SHA256')\n  /**\n   * Appended to the hash of the protocolName during initialization.\n   */\n  public prologue = Buffer.from('lightning')\n  /**\n   * Local secret is a 32-bit private key valid in elliptic curve\n   * secp256k1. This value is unique to the node and should be\n   * chosen with strong cryptographic randomness.\n   */\n  public ls: Buffer\n  /**\n   * Local compressed public key derviced from the local secret `ls`.\n   * This value is stored as a 33-byte buffer.\n   */\n  public lpk: Buffer\n  /**\n   * Ephemeral secret is a 32-bit private key valid in elliptic curve\n   * secp256k1. This value is generated by each node for each connection.\n   * This value must be generated with strong cryptographic randomness.\n   */\n  public es: Buffer\n  /**\n   * Ephemeral compressed public key derived from the ephemeral secret\n   * `es`. This value is stored as a 33-byte buffer.\n   */\n  public epk: Buffer\n  /**\n   * Remote compressed public key stored as a 33-byte buffer.\n   */\n  public rpk: Buffer\n  /**\n   * Remote party's ephemeral public key as a 33-byte buffer storing\n   * the compressed public key. This value is extracted in act 2 where\n   * it is sent during act 1 to the opposing side.\n   */\n  public repk: Buffer\n  /**\n   * Hanshake hash. This value is the accumulated hash of all handshake data that\n   * has been sent and received during the handshake process.\n   */\n  public h: Buffer\n  /**\n   * Chaining key. This value is the accumulated hash of all previous ECDH outputs.\n   * At the end of the handshake, `ck` is used to dervice the encryption keys\n   * for messages.\n   */\n  public ck: Buffer\n  /**\n   * The key used is the receiving key used to decrypt messages sent by the\n   * other side. It is generated in Act3.\n   */\n  public rk: Buffer\n  /**\n   * The key used by the sender to encrypt messages to the receiver. This value\n   * is generated in Act3.\n   */\n  public sk: Buffer\n  /**\n   * Nonce incremented when sending messages. Initialized to zero in Act3.\n   */\n  public sn: Buffer\n  /**\n   * Nonce incremented when receiving messages. Initialized to zero in Act3.\n   */\n  public rn: Buffer\n  /**\n   * Intermediate key 1. Used to encrypt or decrypt the zero-length AEAD\n   * payload in the corresponding initiator or receiver act.\n   */\n  public tempK1: Buffer\n  /**\n   * Intermediate key 2. Used to encrypt or decrypt the zero-length AEAD\n   * payload in the corresponding initiator or receiver act.\n   */\n  public tempK2: Buffer\n  /**\n   * Intermediate key 3. Used to encrypt or decrypt the zero-length AEAD\n   * payload in the corresponding initiator or receiver act.\n   */\n  public tempK3: Buffer\n  /**\n   * State machine for perforing noise-protocol handshake, message\n   * encryption and decryption, and key rotation.\n   */\n  constructor({ ls, es }: NoiseStateOptions) {\n    this.ls = ls\n    this.lpk = getPublicKey(ls)\n    this.es = es\n    this.epk = getPublicKey(es)\n  }\n  /**\n   * Initiator Act1 is the starting point for the authenticated key exchange\n   * handshake. The initiator attempts to satisfy an implicit challenge by the\n   * responder: knowledge of the static public key of the responder. It also\n   * transmits the initiators ephemeral key.\n   * @param rpk remote public key\n   * @return Buffer that is 50 bytes\n   */\n  public async initiatorAct1(rpk: Buffer): Promise<Buffer> {\n    this.rpk = rpk\n    await this._initialize(this.rpk)\n\n    // 2. h = SHA-256(h || epk)\n    this.h = await sha256(Buffer.concat([this.h, this.epk]))\n\n    // 3. es = ECDH(e.priv, rs)\n    const ss = ecdh(this.rpk, this.es)\n\n    // 4. ck, temp_k1 = HKDF(ck, es)\n    const tempK1 = hkdf(ss, 64, this.ck)\n    this.ck = tempK1.subarray(0, 32)\n    this.tempK1 = tempK1.subarray(32)\n\n    // 5. c = encryptWithAD(temp_k1, 0, h, zero)\n    const c = ccpEncrypt(this.tempK1, Buffer.alloc(12), this.h, Buffer.alloc(0))\n\n    // 6. h = SHA-256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 7. m = 0 || epk || c\n    const m = Buffer.concat([Buffer.alloc(1), this.epk, c])\n    return m\n  }\n  /**\n   * Initiator Act2 handles the response generated by the receiver's\n   * Act1, a 50-byte message. The responder's ephemeral key is extacted\n   * from the message during this phase.\n   *\n   * @param m 50-byte message from responder's act1\n   */\n  public async initiatorAct2(m: Buffer) {\n    // 1. read exactly 50 bytes off the stream\n    if (m.length !== 50) throw new Error('ACT2_READ_FAILED')\n    // 2. parse th read message m into v, re, and c\n    const v = m.subarray(0, 1)[0]\n    const re = m.subarray(1, 34)\n    const c = m.subarray(34)\n    // 2a. convert re to public key\n    this.repk = re\n    // 3. assert version is known version\n    if (v !== 0) throw new Error('ACT2_BAD_VERSION')\n    // 4. sha256(h || re.serializedCompressed');\n    this.h = await sha256(Buffer.concat([this.h, this.repk]))\n    // 5. ss = ECDH(re, e.priv);\n    const ss = ecdh(this.repk, this.es)\n    // 6. ck, temp_k2 = HKDF(cd, ss)\n    const tempK2 = hkdf(ss, 64, this.ck)\n    this.ck = tempK2.subarray(0, 32)\n    this.tempK2 = tempK2.subarray(32)\n    // 7. p = decryptWithAD()\n    ccpDecrypt(this.tempK2, Buffer.alloc(12), this.h, c)\n    // 8. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n  }\n  /**\n   * Initiator Act3 is the final phase in the authenticated\n   * key agreement. This act is executed only if act 2\n   * was successful. The initiator transports its static public key\n   * to the responder.\n   */\n  public async initiatorAct3() {\n    // 1. c = encryptWithAD(temp_k2, 1, h, lpk)\n    const c = ccpEncrypt(\n      this.tempK2,\n      Buffer.from([0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]),\n      this.h,\n      this.lpk\n    )\n    // 2. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 3. ss = ECDH(re, s.priv)\n    const ss = ecdh(this.repk, this.ls)\n    // 4. ck, temp_k3 = HKDF(ck, ss)\n    const tempK3 = hkdf(ss, 64, this.ck)\n    this.ck = tempK3.subarray(0, 32)\n    this.tempK3 = tempK3.subarray(32)\n    // 5. t = encryptWithAD(temp_k3, 0, h, zero)\n    const t = ccpEncrypt(this.tempK3, Buffer.alloc(12), this.h, Buffer.alloc(0))\n    // 6. sk, rk = hkdf(ck, zero)\n    const sk = hkdf(Buffer.alloc(0), 64, this.ck)\n    this.rk = sk.subarray(32)\n    this.sk = sk.subarray(0, 32)\n    // 7. rn = 0, sn = 0\n    this.sn = Buffer.alloc(12)\n    this.rn = Buffer.alloc(12)\n    // 8. send m = 0 || c || t\n    const m = Buffer.concat([Buffer.alloc(1), c, t])\n    return m\n  }\n  /**\n   * Receiver Act1 extracts the initiators ephemeral key. It also\n   * validates that the initiator knows the receivers public key.\n   * @param m 50-byte message sent by the initiator\n   */\n  public async receiveAct1(m: Buffer) {\n    await this._initialize(this.lpk)\n    // 1. read exactly 50 bytes off the stream\n    if (m.length !== 50) throw new Error('ACT1_READ_FAILED')\n    // 2. parse th read message m into v,re, and c\n    const v = m.subarray(0, 1)[0]\n    const re = m.subarray(1, 34)\n    const c = m.subarray(34)\n    this.repk = re\n    // 3. assert version is known version\n    if (v !== 0) throw new Error('ACT1_BAD_VERSION')\n    // 4. sha256(h || re.serializedCompressed');\n    this.h = await sha256(Buffer.concat([this.h, re]))\n    // 5. ss = ECDH(re, ls.priv);\n    const ss = ecdh(re, this.ls)\n    // 6. ck, temp_k1 = HKDF(cd, ss)\n    const tempK1 = hkdf(ss, 64, this.ck)\n    this.ck = tempK1.subarray(0, 32)\n    this.tempK1 = tempK1.subarray(32)\n    // 7. p = decryptWithAD(temp_k1, 0, h, c)\n    ccpDecrypt(this.tempK1, Buffer.alloc(12), this.h, c)\n    // 8. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n  }\n  /**\n   * Receiver Act2 takes place only if Act1 was successful.\n   * This act sends responder's ephermeral key to the initiator.\n   */\n  public async recieveAct2(): Promise<Buffer> {\n    // 1. e = generateKey() => done in initialization\n    // 2. h = sha256(h || e.pub.compressed())\n    this.h = await sha256(Buffer.concat([this.h, this.epk]))\n    // 3. ss = ecdh(re, e.priv)\n    const ss = ecdh(this.repk, this.es)\n    // 4. ck, temp_k2 = hkdf(ck, ss)\n    const tempK2 = hkdf(ss, 64, this.ck)\n    this.ck = tempK2.subarray(0, 32)\n    this.tempK2 = tempK2.subarray(32)\n    // 5. c = encryptWithAd(temp_k2, 0, h, zero)\n    const c = ccpEncrypt(this.tempK2, Buffer.alloc(12), this.h, Buffer.alloc(0))\n    // 6. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 7. m = 0 || e.pub.compressed() Z|| c\n    const m = Buffer.concat([Buffer.alloc(1), this.epk, c])\n    return m\n  }\n  /**\n   * Receiver Act3 is the final phase in the authenticated key\n   * agreement. This act is executed only if act 2 was successful.\n   * The receiver extracts the public key of the initiator.\n   * @param m 66-byte message\n   */\n  public async receiveAct3(m: Buffer) {\n    // 1. read exactly 66 bytes from the network buffer\n    if (m.length !== 66) throw new Error('ACT3_READ_FAILED')\n    // 2. parse m into v, c, t\n    const v = m.subarray(0, 1)[0]\n    const c = m.subarray(1, 50)\n    const t = m.subarray(50)\n    // 3. validate v is recognized\n    if (v !== 0) throw new Error('ACT3_BAD_VERSION')\n    // 4. rs = decryptWithAD(temp_k2, 1, h, c)\n    const rs = ccpDecrypt(this.tempK2, Buffer.from('000000000100000000000000', 'hex'), this.h, c)\n    this.rpk = rs as Buffer\n    // 5. h = sha256(h || c)\n    this.h = await sha256(Buffer.concat([this.h, c]))\n    // 6. ss = ECDH(rs, e.priv)\n    const ss = ecdh(this.rpk, this.es)\n    // 7. ck, temp_k3 = hkdf(cs, ss)\n    const tempK3 = hkdf(ss, 64, this.ck)\n    this.ck = tempK3.subarray(0, 32)\n    this.tempK3 = tempK3.subarray(32)\n    // 8. p = decryptWithAD(temp_k3, 0, h, t)\n    ccpDecrypt(this.tempK3, Buffer.alloc(12), this.h, t)\n    // 9. rk, sk = hkdf(ck, zero)\n    const sk = hkdf(Buffer.alloc(0), 64, this.ck)\n    this.rk = sk.subarray(0, 32)\n    this.sk = sk.subarray(32)\n    // 10. rn = 0, sn = 0\n    this.rn = Buffer.alloc(12)\n    this.sn = Buffer.alloc(12)\n  }\n  /**\n   * Sends an encrypted message using the shared sending key and nonce.\n   * The nonce is rotated once the message is sent. The sending key is\n   * rotated every 1000 messages.\n   * @param m\n   */\n  public async encryptMessage(m: Buffer): Promise<Buffer> {\n    // step 1/2. serialize m length into int16\n    const l = Buffer.alloc(2)\n    l.writeUInt16BE(m.length, 0)\n    // step 3. encrypt l, using chachapoly1305, sn, sk)\n    const lc = ccpEncrypt(this.sk, this.sn, Buffer.alloc(0), l)\n    // step 3a: increment sn\n    if (this._incrementSendingNonce() >= 1000) this._rotateSendingKeys()\n    // step 4 encrypt m using chachapoly1305, sn, sk\n    const c = ccpEncrypt(this.sk, this.sn, Buffer.alloc(0), m)\n    // step 4a: increment sn\n    if (this._incrementSendingNonce() >= 1000) this._rotateSendingKeys()\n    // step 5 return m to be sent\n    return Buffer.concat([lc, c])\n  }\n  /**\n   * Decrypts the length of the message using the receiving key and nonce.\n   * The receiving key is rotated every 1000 messages.\n   */\n  public async decryptLength(lc: Buffer): Promise<number> {\n    const l = ccpDecrypt(this.rk, this.rn, Buffer.alloc(0), lc) as Buffer\n    if (this._incrementRecievingNonce() >= 1000) this._rotateRecievingKeys()\n    return l.readUInt16BE(0)\n  }\n  /**\n   * Decrypts the message using the receiving key and nonce. The receiving\n   * key is rotated every 1000 messages.\n   */\n  public async decryptMessage(c: Buffer) {\n    const m = ccpDecrypt(this.rk, this.rn, Buffer.alloc(0), c)\n    if (this._incrementRecievingNonce() >= 1000) this._rotateRecievingKeys()\n    return m as Buffer\n  }\n  /////////////////////////////////////\n  /**\n   * Initializes the noise state prior to Act1.\n   */\n  private async _initialize(pubkey: Buffer) {\n    // 1. h = SHA-256(protocolName)\n    this.h = await sha256(Buffer.from(this.protocolName))\n\n    // 2. ck = h\n    this.ck = this.h\n\n    // 3. h = SHA-256(h || prologue)\n    this.h = await sha256(Buffer.concat([this.h, this.prologue]))\n\n    // 4. h = SHA-256(h || pubkey)\n    this.h = await sha256(Buffer.concat([this.h, pubkey]))\n  }\n\n  private _incrementSendingNonce() {\n    const newValue = this.sn.readUInt16LE(4) + 1\n    this.sn.writeUInt16LE(newValue, 4)\n    return newValue\n  }\n\n  private _incrementRecievingNonce() {\n    const newValue = this.rn.readUInt16LE(4) + 1\n    this.rn.writeUInt16LE(newValue, 4)\n    return newValue\n  }\n\n  private _rotateSendingKeys() {\n    const result = hkdf(this.sk, 64, this.ck)\n    this.sk = result.subarray(32)\n    this.ck = result.subarray(0, 32)\n    this.sn = Buffer.alloc(12)\n  }\n\n  private _rotateRecievingKeys() {\n    const result = hkdf(this.rk, 64, this.ck)\n    this.rk = result.subarray(32)\n    this.ck = result.subarray(0, 32)\n    this.rn = Buffer.alloc(12)\n  }\n}\n","import { Buffer } from 'buffer'\n\n/**\n * BufferReader class is used to simplify reading information from a Buffer\n */\nexport class BufferReader {\n  /**\n   * Returns the number of bytes that will be used to encode\n   * a BigSize number. BigSize is defined in Lightning Network BOLT 07\n   */\n  public static bigSizeBytes(num: bigint): number {\n    if (num < BigInt(0xfd)) return 1\n    if (num < BigInt(0x10000)) return 3\n    if (num < BigInt(0x100000000)) return 5\n    else return 9\n  }\n\n  private _buffer: Buffer\n  private _position: number\n  private _lastReadBytes: number\n\n  /**\n   * Constructs a reader from the supplied Buffer\n   */\n  constructor(buffer: Buffer) {\n    this._buffer = buffer\n    this._position = 0\n    this._lastReadBytes = 0\n  }\n\n  /**\n   * Gets or sets the current position of the cursor in the buffer\n   */\n  public get position(): number {\n    return this._position\n  }\n\n  public set position(val: number) {\n    this._position = val\n  }\n\n  /**\n   * Gets if the cursor is at the end of file.\n   */\n  public get eof(): boolean {\n    return this._position === this._buffer.length\n  }\n\n  /**\n   * Gets the underlying buffer that the cursor\n   * is reading from.\n   */\n  public get buffer(): Buffer {\n    return this._buffer\n  }\n\n  /**\n   * Number of bytes read in last operation executed on the cursor.\n   * Especially useful for operations that return variable length of\n   * results such as readBytes or readVarUint.\n   */\n  public get lastReadBytes(): number {\n    return this._lastReadBytes\n  }\n\n  /**\n   * Read a UInt8 number\n   */\n  public readUInt8(): number {\n    return this._readStandard(this.readUInt8.name, 1)\n  }\n\n  /**\n   * Read a UInt16 number as little-endian\n   */\n  public readUInt16LE(): number {\n    return this._readStandard(this.readUInt16LE.name, 2)\n  }\n\n  /**\n   * Read a UInt16 number as big-endian\n   */\n  public readUInt16BE(): number {\n    return this._readStandard(this.readUInt16BE.name, 2)\n  }\n\n  /**\n   * Read a UInt32 number as little-endian\n   */\n  public readUInt32LE(): number {\n    return this._readStandard(this.readUInt32LE.name, 4)\n  }\n\n  /**\n   * Read a UInt32 number as big-endian\n   */\n  public readUInt32BE(): number {\n    return this._readStandard(this.readUInt32BE.name, 4)\n  }\n\n  /**\n   * Read a UInt64 number as big-endian\n   */\n  public readUInt64BE(): bigint {\n    return BigInt('0x' + this.readBytes(8).toString('hex'))\n  }\n\n  /**\n   * Read a UInt64 number as little-endian\n   */\n  public readUInt64LE(): bigint {\n    return BigInt('0x' + this.readBytes(8).reverse().toString('hex'))\n  }\n\n  /**\n   * Reads a variable length unsigned integer as specified in the protocol\n   * documentation and aways returns a BN to maintain a consistant call\n   * signature.\n   *\n   * @remarks\n   * Specified in:\n   * https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\n   *\n   * Reads the first byte and determines the length of the remaining integer.\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public readVarUint(): bigint | void {\n    const size = this.readUInt8()\n    if (size < 0xfd) {\n      this._lastReadBytes = 1\n      return BigInt(size)\n    }\n    switch (size) {\n      case 0xfd:\n        this._lastReadBytes = 3\n        return BigInt(this.readUInt16LE())\n      case 0xfe:\n        this._lastReadBytes = 5\n        return BigInt(this.readUInt32LE())\n      case 0xff:\n        this._lastReadBytes = 9\n        return this.readUInt64LE()\n    }\n  }\n\n  /**\n   * Reads a variable length unsigned integer as specified in the Lightning Network\n   * protocol documentation and always returns a BigInt to maintain a consistent\n   * call signature.\n   *\n   * @remarks\n   * Specified in:\n   * https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#appendix-a-bigsize-test-vectors\n   *\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public readBigSize(): bigint {\n    const size = this.readUInt8()\n\n    if (size < 0xfd) {\n      this._lastReadBytes = 1\n      return BigInt(size)\n    }\n    switch (size) {\n      case 0xfd: {\n        this._lastReadBytes = 3\n        const val = this.readUInt16BE()\n        if (val < 0xfd) throw new Error('decoded varint is not canonical')\n        return BigInt(val)\n      }\n      case 0xfe: {\n        this._lastReadBytes = 5\n        const val = this.readUInt32BE()\n        if (val < 0x10000) throw new Error('decoded varint is not canonical')\n        return BigInt(val)\n      }\n      case 0xff: {\n        this._lastReadBytes = 9\n        const val = this.readUInt64BE()\n        if (val < BigInt(0x100000000)) throw new Error('decoded varint is not canonical')\n        return val\n      }\n      default:\n        throw new Error(`Unrecognised size: ${size} when trying to read BigSize`)\n    }\n  }\n\n  /**\n   * Read bytes from the buffer into a new Buffer. Unlike the default\n   * slice method, the values do not point to the same memory location\n   * as the source buffer. The values are copied to a new buffer.\n   *\n   * @param len optional number of bytes to read, returns\n   * all remaining bytes when omitted\n   */\n  public readBytes(len?: number): Buffer {\n    if (len === 0) {\n      this._lastReadBytes = 0\n      return Buffer.alloc(0)\n    } else if (typeof len === 'number' && len > 0) {\n      if (this._position + len > this._buffer.length) {\n        throw new RangeError('Index out of range')\n      }\n      const slice = this._buffer.subarray(this._position, this._position + len)\n      const result = Buffer.alloc(slice.length, slice)\n      this._position += len\n      this._lastReadBytes = len\n      return result\n    } else {\n      if (this._position === this._buffer.length) {\n        this._lastReadBytes = 0\n        return Buffer.alloc(0)\n      }\n      const slice = this._buffer.subarray(this._position)\n      const result = Buffer.alloc(slice.length, slice)\n      this._position = this._buffer.length\n      this._lastReadBytes = result.length\n      return result\n    }\n  }\n\n  /**\n   * Reads bytes from the buffer at the current position without\n   * moving the cursor.\n   * @param len optional number of bytes to read\n   */\n  public peakBytes(len?: number): Buffer {\n    if (len === 0) {\n      return Buffer.alloc(0)\n    } else if (typeof len === 'number' && len > 0) {\n      if (this._position + len > this._buffer.length) {\n        throw new RangeError('Index out of range')\n      }\n      const slice = this._buffer.subarray(this._position, this._position + len)\n      const result = Buffer.alloc(slice.length, slice)\n      return result\n    } else {\n      if (this._position === this._buffer.length) throw new RangeError('Index out of range')\n      const slice = this._buffer.subarray(this._position)\n      const result = Buffer.alloc(slice.length, slice)\n      return result\n    }\n  }\n\n  /**\n   * TLV 0 to 2 byte unsigned integer encoded in big-endian.\n   */\n  public readTUInt16(): number {\n    const size = Math.min(2, this._buffer.length - this._position)\n    if (size === 0) return 0\n    const val = this._buffer.readUIntBE(this._position, size)\n    this._assertMinimalTUInt(BigInt(val), size)\n    this._position += size\n    return val\n  }\n\n  /**\n   * TLV 0 to 4 byte unsigned integer encoded in big-endian.\n   */\n  public readTUInt32(): number {\n    const size = Math.min(4, this._buffer.length - this._position)\n    if (size === 0) return 0\n    const val = this._buffer.readUIntBE(this._position, size)\n    this._assertMinimalTUInt(BigInt(val), size)\n    this._position += size\n    return val\n  }\n\n  /**\n   * TLV 0 to 8 byte unsigned integer encoded in big-endian.\n   */\n  public readTUInt64(): bigint {\n    const size = Math.min(8, this._buffer.length - this._position)\n    if (size === 0) return BigInt(0)\n    const hex = this._buffer.subarray(this._position, this._position + size).toString('hex') || '0'\n    const val = BigInt('0x' + hex)\n    this._assertMinimalTUInt(val, size)\n    this._position += size\n    return val\n  }\n\n  /**\n   * Helper for reading off buffer using built-in read functions\n   * @param fn name of function\n   * @param len length to read\n   */\n  private _readStandard(fn: string, len: number): number {\n    if (this._position + len > this._buffer.length) {\n      throw new RangeError('Index out of range')\n    }\n\n    // @ts-ignore\n    const result: number = this._buffer[fn](this._position)\n    this._position += len\n    this._lastReadBytes = len\n    return result\n  }\n\n  /**\n   * Ensures the TUInt value is minimally encoded\n   * @param num\n   * @param bytes\n   */\n  private _assertMinimalTUInt(num: bigint, bytes: number) {\n    const msg = 'TUInt not minimal'\n    for (let i = 0; i < 9; i++) {\n      if (num < BigInt('0x1' + ''.padStart(i * 2, '0'))) {\n        if (bytes !== i) {\n          throw new Error(msg)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Utility class for writing arbitrary data into a Buffer. This class will\n * automatically expand the underlying Buffer and return a trimmed view\n * when complete.\n */\nexport class BufferWriter {\n  private _position: number\n  private _fixed: boolean\n  private _buffer: Buffer\n\n  /**\n   * Constructs a BufferWriter that can optionally wrap an existing Buffer.\n   * If no buffer is provided, the BufferWriter will internally manage an\n   * exponentially growing Buffer to allow writing of data of an unknown size.\n   *\n   * If a Buffer is provided, writing that would overflow will throw an\n   * exception.\n   * @param buffer\n   */\n  constructor(buffer?: Buffer) {\n    this._position = 0\n    this._fixed = !!buffer\n    this._buffer = buffer || Buffer.alloc(0)\n  }\n\n  /**\n   * Gets the current size of the output Buffer\n   */\n  public get size(): number {\n    return this._position\n  }\n\n  /**\n   * Returns the Buffer which will be either the full Buffer if this was a\n   * fixed Buffer or will be the expandable Buffer sliced to the current\n   * position\n   */\n  public toBuffer(): Buffer {\n    if (this._fixed) return this._buffer\n    else return this._buffer.subarray(0, this._position)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt8(val: number) {\n    this._writeStandard(this.writeUInt8.name, val, 1)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt16LE(val: number) {\n    this._writeStandard(this.writeUInt16LE.name, val, 2)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt16BE(val: number) {\n    this._writeStandard(this.writeUInt16BE.name, val, 2)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt32LE(val: number) {\n    this._writeStandard(this.writeUInt32LE.name, val, 4)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param val\n   */\n  public writeUInt32BE(val: number) {\n    this._writeStandard(this.writeUInt32BE.name, val, 4)\n  }\n\n  /**\n   * Write at the current positiion\n   * @param value\n   */\n  public writeUInt64LE(value: number | bigint) {\n    const val = BigInt(value)\n    if (val < 0 || val >= BigInt(2) ** BigInt(64)) {\n      throw new RangeError(\n        `The value of \"value\" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${value.toString()}`\n      )\n    }\n    const buf = Buffer.from(val.toString(16).padStart(16, '0'), 'hex')\n    this.writeBytes(buf.reverse())\n  }\n\n  /**\n   * Write at the current positiion\n   * @param value\n   */\n  public writeUInt64BE(value: number | bigint) {\n    const val = BigInt(value)\n    if (val < 0 || val >= BigInt(2) ** BigInt(64)) {\n      throw new RangeError(\n        `The value of \"value\" is out of range. It must be >= 0 and <= 18446744073709551615. Received ${value.toString()}`\n      )\n    }\n    const buf = Buffer.from(val.toString(16).padStart(16, '0'), 'hex')\n    this.writeBytes(buf)\n  }\n\n  /**\n   * Write bytes at the current positiion\n   * @param buffer\n   */\n  public writeBytes(buffer: Buffer) {\n    if (!buffer || !buffer.length) return\n    this._expand(buffer.length)\n    buffer.copy(this._buffer, this._position)\n    this._position += buffer.length\n  }\n\n  /**\n   * Reads a variable length unsigned integer in little-endian as specified in\n   * the Bitcoin protocol documentation.\n   *\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public writeVarInt(val: bigint | number) {\n    const num = BigInt(val)\n    if (num < BigInt(0xfd)) {\n      this.writeUInt8(Number(num))\n    } else if (num < BigInt(0x10000)) {\n      this.writeUInt8(0xfd)\n      this.writeUInt16LE(Number(num))\n    } else if (num < BigInt(0x100000000)) {\n      this.writeUInt8(0xfe)\n      this.writeUInt32LE(Number(num))\n    } else {\n      this.writeUInt8(0xff)\n      this.writeUInt64LE(num)\n    }\n  }\n\n  /**\n   * Reads a variable length unsigned integer as specified in the Lightning Network\n   * protocol documentation and always returns a BigInt to maintain a consistent\n   * call signature.\n   *\n   * @remarks\n   * Specified in:\n   * https://github.com/lightningnetwork/lightning-rfc/blob/master/01-messaging.md#appendix-a-bigsize-test-vectors\n   *\n   * < 0xfd = 1 byte number\n   *   0xfd = 2 byte number (3 bytes total)\n   *   0xfe = 4 byte number (5 bytes total)\n   *   0xff = 8 byte number (9 bytes total)\n   */\n  public writeBigSize(val: bigint | number) {\n    const num = BigInt(val)\n    if (num < BigInt(0xfd)) {\n      this.writeUInt8(Number(num))\n    } else if (num < BigInt(0x10000)) {\n      this.writeUInt8(0xfd)\n      this.writeUInt16BE(Number(num))\n    } else if (num < BigInt(0x100000000)) {\n      this.writeUInt8(0xfe)\n      this.writeUInt32BE(Number(num))\n    } else {\n      this.writeUInt8(0xff)\n      this.writeUInt64BE(num)\n    }\n  }\n\n  /**\n   * TLV 0 to 2 byte unsigned integer encoded in big-endian.\n   * @param val\n   */\n  public writeTUInt16(val: number) {\n    if (val === 0) return\n    const size = val > 0xff ? 2 : 1\n    this._expand(size)\n    this._buffer.writeUIntBE(val, this._position, size)\n    this._position += size\n  }\n\n  /**\n   * TLV 0 to 4 byte unsigned integer encoded in big-endian.\n   */\n  public writeTUInt32(val: number) {\n    if (val === 0) return\n    const size = val > 0xffffff ? 4 : val > 0xffff ? 3 : val > 0xff ? 2 : 1\n    this._expand(size)\n    this._buffer.writeUIntBE(val, this._position, size)\n    this._position += size\n  }\n\n  /**\n   * TLV 0 to 8 byte unsigned integer encoded in big-endian.\n   */\n  public writeTUInt64(val: bigint) {\n    if (val === BigInt(0)) return\n    let valString = val.toString(16)\n    if (valString.length % 2 === 1) valString = '0' + valString\n    const buf = Buffer.from(valString, 'hex')\n    this.writeBytes(buf)\n  }\n\n  /**\n   * Expands the underlying buffer as needed by doubling the size of the\n   * Buffer when it needs to grow.\n   * @param needed\n   */\n  private _expand(needed: number) {\n    const required = this._position + needed\n\n    // Ensure that a fixed Buffer length is not violated\n    if (this._fixed && required > this._buffer.length) {\n      throw new RangeError('Out of range')\n    }\n\n    // expand the buffer if the current buffer is insufficiently lengthed\n    if (this._buffer.length < required) {\n      // calculate the new length based on the required length and some\n      // maths where we determine the number of bytes required and at the\n      // next power of 2.\n      const newLen = 1 << Math.ceil(Math.log2(required))\n      const newBuf = Buffer.alloc(newLen)\n\n      // copy the old data to the new buffer and then dispose of the old\n      // buffer\n      this._buffer.copy(newBuf)\n      this._buffer = newBuf\n    }\n  }\n\n  /**\n   * Helper for writing to the buffer using built-in write\n   * functions\n   * @param fn name of function\n   * @param val number to write\n   * @param len length of number in bytes\n   */\n  private _writeStandard(fn: string, val: number, len: number) {\n    this._expand(len)\n    // @ts-ignore\n    this._buffer[fn](val, this._position)\n    this._position += len\n  }\n}\n","import * as bigintutil from './BigIntUtils'\nimport { Buffer } from 'buffer'\n\ntype BigIntInput = string | number | bigint | boolean\n\n/**\n * BitField assists with using bit flags to set or unset values in the bit\n * field. Preferrably a flag type is provided, otherwise it defaults to allow\n * arbitrary setting of integers corresponding to a particular bit index.\n *\n * Internally, values are stored as bigint so that more than 32 values\n * can be used since there is a limit of 31 digits that can be manipulated\n * using bitwise operations in JavaScript.\n */\nexport class BitField<T = number> {\n  /**\n   * Constructs a bitmask from a number\n   */\n  public static fromNumber(value: number) {\n    return new BitField(BigInt(value))\n  }\n\n  /**\n   * Constructs a bitmask from a buffer\n   */\n  public static fromBuffer(value: Buffer) {\n    if (value.length === 0) return new BitField()\n    return new BitField(BigInt('0x' + value.toString('hex')))\n  }\n\n  public value: bigint\n\n  constructor(value?: bigint) {\n    this.value = value || BigInt(0)\n  }\n\n  public isSet(bit: BigIntInput): boolean {\n    return (this.value & (BigInt(1) << BigInt(bit))) > BigInt(0)\n  }\n\n  public set(bit: BigIntInput) {\n    this.value |= BigInt(1) << BigInt(bit)\n  }\n\n  public unset(bit: BigIntInput) {\n    this.value &= ~(this.value & (BigInt(1) << BigInt(bit)))\n  }\n\n  public toggle(bit: BigIntInput) {\n    this.value ^= BigInt(1) << BigInt(bit)\n  }\n\n  /**\n   * Returns the full list of set flags for the bit field\n   */\n  public flags(): T[] {\n    const bits: T[] = []\n    let bit = 0\n    let val = 1n\n    while (val < this.value) {\n      if (this.value & val) bits.push(bit as any)\n      bit += 1\n      val <<= 1n\n    }\n    return bits\n  }\n\n  /**\n   * Returns the index of the most-significant bit that is set\n   */\n  public msb(): number {\n    let num = this.value\n    let bit = 0\n    while (num > 1) {\n      num = num >> 1n\n      bit += 1\n    }\n    return bit\n  }\n\n  /**\n   * Returns a new BitField with the bitwise AND of the two BitFields\n   * @param bitfield\n   */\n  public and(bitfield: BitField): BitField {\n    return new BitField(this.value & bitfield.value)\n  }\n\n  /**\n   * Returns a new BitField with the bitwise OR of the two BitFields\n   * @param bitfield\n   */\n  public or(bitfield: BitField): BitField {\n    return new BitField(this.value | bitfield.value)\n  }\n\n  /**\n   * Returns a new BitField with the bitwise XOR of the two BitFields\n   * @param bitfield\n   */\n  public xor(bitfield: BitField): BitField {\n    return new BitField(this.value ^ bitfield.value)\n  }\n\n  public toBigInt() {\n    return this.value\n  }\n\n  public toNumber() {\n    return Number(this.value)\n  }\n\n  public toBuffer(): Buffer {\n    if (this.value === BigInt(0)) return Buffer.alloc(0)\n    return bigintutil.bigintToBuffer(this.value)\n  }\n}\n","import { Buffer } from 'buffer'\n\nexport function calcBytes(num: bigint) {\n  let b = 0\n  while (num > BigInt(0)) {\n    b += 1\n    num /= BigInt(2 ** 8)\n  }\n  return b\n}\n\nexport function bigintToBuffer(num: bigint): Buffer {\n  const bytes = calcBytes(num)\n  return Buffer.from(num.toString(16).padStart(bytes * 2, '0'), 'hex')\n}\n","export type LnWebSocketOptions = {\n  /**\n   * 33-byte hex remote compressed public key.\n   * The identity of the node you would like to initiate a connection with\n   */\n  remoteNodePublicKey: string\n  /**\n   * The IP address of the remote node\n   */\n  ip: string\n  /**\n   * The port of the remote node. Defaults to 9735\n   */\n  port?: number\n  /**\n   * A WebSocket proxy endpoint for the browser to connect to,\n   * so that a server can create a direct connection to the node without the need for a tls certificate runnning on the remote node\n   * or if the Lightning node implementation does not support WebSocket connections directly\n   * Checkout https://github.com/clams-tech/lnsocket-proxy and https://github.com/jb55/ln-ws-proxy\n   */\n  wsProxy?: string\n  /**\n   * 32 byte hex encoded private key to be used as the local node secret.\n   * Use this to ensure a consistent local node identity across connection sessions\n   */\n  privateKey?: string\n  /**\n   Logger object to log info, warn, and error logs\n   */\n  logger?: Logger\n}\n\nexport type NoiseStateOptions = {\n  /**\n   * Local private key as a 32-byte buffer\n   */\n  ls: Buffer\n\n  /**\n   * Ephemeral private key as a 32-byte\n   */\n  es: Buffer\n}\n\n/**\n * Defined in BOLT01\n */\nexport enum MessageType {\n  // Setup and Control (0 - 31)\n  Init = 16,\n  Error = 17,\n  Ping = 18,\n  Pong = 19,\n\n  // Channel (32-127)\n  OpenChannel = 32,\n  AcceptChannel = 33,\n  FundingCreated = 34,\n  FundingSigned = 35,\n  FundingLocked = 36,\n  Shutdown = 38,\n  ClosingSigned = 39,\n\n  // Commitment (128-255)\n  //\n\n  // Routing (256-511)\n  ChannelAnnouncement = 256,\n  NodeAnnouncement = 257,\n  ChannelUpdate = 258,\n  AnnouncementSignatures = 259,\n  QueryShortChannelIds = 261,\n  ReplyShortChannelIdsEnd = 262,\n  QueryChannelRange = 263,\n  ReplyChannelRange = 264,\n  GossipTimestampFilter = 265,\n\n  CommandoRequest = 19535,\n  CommandoResponseContinues = 22859,\n  CommandoResponse = 22861\n}\n\n/**\n * States that the handshake process can be in. States depend on\n * whether the socket is the connection Initiator or Responder.\n *\n * Initiator:\n *   1.  create and send Iniatitor act1 and transition to\n *       AWAITING_RESPONDER_REPLY\n *   2.  process the Responder's reply as act2\n *   3.  create Initiator act3 reply to complete the handshake\n *       and transitions to READY\n *\n * Responder:\n *   1.  begins in AWAITING_INITIATOR waiting to receive act1\n *   2.  processes act1 and creates a reply as act2 and transitions\n *       to AWAITING_INITIATOR_REPLY\n *   3.  processes the Initiator's reply to complete the handshake\n *       and transition to READY\n */\nexport enum HANDSHAKE_STATE {\n  /**\n   * Initial state for the Initiator. Initiator will transition to\n   * AWAITING_RESPONDER_REPLY once act1 is completed and sent.\n   */\n  INITIATOR_INITIATING = 0,\n\n  /**\n   * Responders begin in this state and wait for the Intiator to begin\n   * the handshake. Sockets originating from the NoiseServer will\n   * begin in this state.\n   */\n  AWAITING_INITIATOR = 1,\n\n  /**\n   * Initiator has sent act1 and is awaiting the reply from the responder.\n   * Once received, the intiator will create the reply\n   */\n  AWAITING_RESPONDER_REPLY = 2,\n\n  /**\n   * Responder has  sent a reply to the inititator, the Responder will be\n   * waiting for the final stage of the handshake sent by the Initiator.\n   */\n  AWAITING_INITIATOR_REPLY = 3,\n\n  /**\n   * Responder/Initiator have completed the handshake and we're ready to\n   * start sending and receiving over the socket.\n   */\n  READY = 100\n}\n\nexport enum READ_STATE {\n  READY_FOR_LEN = 2,\n  READY_FOR_BODY = 3,\n  BLOCKED = 4\n}\n\nexport type JsonRpcRequest = {\n  /**The RPC method you would like to call*/\n  method: string\n  /**The params to for the above method.\n   * Can be an object with named parameters (like the -k options for the CLI)\n   * or an array of ordered params. If no value is passed in it defaults to an\n   * empty array\n   */\n  params?: unknown | unknown[]\n}\n\ntype JsonRpcBaseResponse = {\n  jsonrpc: string\n  id: string | number | null\n}\n\nexport type JsonRpcSuccessResponse = JsonRpcBaseResponse & { result: unknown }\n\nexport type JsonRpcErrorResponse = JsonRpcBaseResponse & {\n  error: { code: number; message: string; data?: unknown }\n}\n\nexport type CommandoRequest = JsonRpcRequest & {\n  /**Base64 encoded rune token as outputted by the commando-rune cli command\n   * If the rune does not have adequate permissions for this request an error will\n   * be returned\n   */\n  rune: string\n  /**Optional 8 byte hex encoded random string for matching the request to a response\n   * Lnmessage will handle this automatically, but in some instances it is handy to know the\n   * request id ahead of time\n   */\n  reqId?: string\n}\n\nexport type CommandoResponse = JsonRpcSuccessResponse | JsonRpcErrorResponse\n\nexport type Logger = {\n  info: (msg: string) => void\n  warn: (msg: string) => void\n  error: (msg: string) => void\n}\n","import { Buffer } from 'buffer'\nimport { BufferReader, BufferWriter } from './buf'\nimport { BitField } from './BitField'\nimport { InitFeatureFlags } from './InitFeatureFlags'\nimport { MessageType } from '../types'\nimport { readTlvs } from './read-tlvs'\nimport { IWireMessage } from './IWireMessage'\n\n/**\n * InitMessage is defined in BOLT #1. Once authentication is complete, the first\n * message reveals the features supported or required by the node sending the\n * message. This message is sent even on a reconnection.\n *\n * This message contains two fields; global features and local features, that\n * are used to signal how the message should operate. The values of are defined\n * in the BOLT #9.\n */\nexport class InitMessage implements IWireMessage {\n  /**\n   * Processes a buffer containing the message information. This method\n   * will capture the arbitrary length global and local\n   * features into two internal properties of the newly constructed\n   * init message object.\n   */\n  public static deserialize(buffer: Buffer): InitMessage {\n    const instance = new InitMessage()\n    const reader = new BufferReader(buffer)\n\n    // read the type bytes\n    reader.readUInt16BE()\n\n    // read the global features and per the specification, the global\n    // features should not exceed features greater than 13.\n    const gflen = reader.readUInt16BE()\n    const gf = BitField.fromBuffer(reader.readBytes(gflen))\n\n    // Read the local length and parse into a BN value.\n    const lflen = reader.readUInt16BE()\n    const lf = BitField.fromBuffer(reader.readBytes(lflen))\n\n    // construct a single features object by bitwise or of the global and\n    // local features.\n    instance.features = new BitField().or(gf).or(lf)\n\n    // process TLVs\n    readTlvs(reader, (type: bigint, valueReader: BufferReader) => {\n      switch (type) {\n        // Process networks TLVs which is a series of chain_hash 32\n        // byte values. This method will simply read from the stream\n        // until every thing has been read\n        case BigInt(1): {\n          while (!valueReader.eof) {\n            const chainHash = valueReader.readBytes(32)\n            instance.chainHashes.push(chainHash)\n          }\n          return true\n        }\n        default:\n          return false\n      }\n    })\n\n    return instance\n  }\n\n  /**\n   * Message type 16\n   */\n  public type: MessageType = MessageType.Init\n\n  /**\n   * BitField containing the features provided in by the local or remote node\n   */\n  public features: BitField<InitFeatureFlags> = new BitField()\n\n  /**\n   * Supported chain_hashes for the remote peer\n   */\n  public chainHashes: Buffer[] = []\n\n  /**\n   * Serialize will construct a properly formatted message based on the\n   * properties of the configured message.\n   */\n  public serialize() {\n    const writer = new BufferWriter()\n\n    // write the type\n    writer.writeUInt16BE(this.type)\n\n    // write gflen\n    const gflen = 0\n    writer.writeUInt16BE(gflen)\n\n    // write features\n    const features = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])\n    const featuresLen = features.length\n    writer.writeUInt16BE(featuresLen)\n    writer.writeBytes(features)\n\n    // write chainhash tlv\n    if (this.chainHashes.length) {\n      writer.writeBigSize(1) // type\n      writer.writeBigSize(this.chainHashes.length * 32) // length\n      writer.writeBytes(Buffer.concat(this.chainHashes)) // value\n    }\n\n    return writer.toBuffer()\n  }\n}\n","import { BufferReader } from './buf'\n\n/**\n * Reads TLVs from a reader until the entire stream is processed. The handler is\n * responsible for doing something with the data bytes.\n * @param reader\n * @param handler\n */\nexport function readTlvs(\n  reader: BufferReader,\n  handler: (type: bigint, value: BufferReader) => boolean\n) {\n  let lastType: bigint = BigInt(-1)\n\n  while (!reader.eof) {\n    try {\n      const type = reader.readBigSize()\n      const len = reader.readBigSize()\n      const value = reader.readBytes(Number(len))\n      const valueReader = new BufferReader(value)\n\n      if (type <= lastType) {\n        throw new Error('Invalid TLV stream')\n      }\n\n      const isEven = type % BigInt(2) === BigInt(0)\n      const wasHandled = handler(type, valueReader)\n\n      if (!wasHandled && isEven) {\n        throw new Error('Unknown even type')\n      }\n\n      if (wasHandled && !valueReader.eof) {\n        throw new Error('Non-canonical length')\n      }\n\n      lastType = type\n    } catch (error) {\n      // tried to read an index out of range\n    }\n  }\n}\n","import { Buffer } from 'buffer'\nimport { BufferReader, BufferWriter } from './buf'\nimport { MessageType } from '../types'\nimport { IWireMessage } from './IWireMessage'\n\nexport const PONG_BYTE_THRESHOLD = 65532\n\n/**\n * In order to allow for the existence of long-lived TCP\n * connections,  at times it may be required that both ends keep\n * alive the TCP connection at the application level.\n *\n * The ping message is sent by an initiator and includes a value\n * for the number of pong bytes it expects to receive as\n * a reply. The ignored bits should be set to 0.\n */\nexport class PingMessage implements IWireMessage {\n  /**\n   * Deserialize a message and return a new instance of the\n   * PingMessage type.\n   */\n  public static deserialize(payload: Buffer): PingMessage {\n    const cursor = new BufferReader(payload)\n    cursor.readUInt16BE()\n\n    const instance = new PingMessage()\n    instance.numPongBytes = cursor.readUInt16BE()\n\n    const bytesLength = cursor.readUInt16BE()\n\n    instance.ignored = cursor.readBytes(bytesLength)\n    return instance\n  }\n\n  /**\n   * Ping message type is 18\n   */\n  public type: MessageType = MessageType.Ping\n\n  /**\n   * The number of bytes that should be returned in the pong message.\n   * Can be set to 65532 to indicate that no pong message should be\n   * sent. Setting to any number below 65532 will require a pong\n   * matching the corresponding number of bytes. If the reply\n   * byteslen does not match this, you may terminate the channels\n   * with the client.\n   */\n  public numPongBytes: number = 1\n\n  /**\n   * Should set ignored to 0s. Must not set ignored to\n   * sensitive data such as secrets or portions of initialized\n   * memory.\n   */\n  public ignored: Buffer = Buffer.alloc(0)\n\n  /**\n   * Serialize the PingMessage and return a Buffer\n   */\n  public serialize(): Buffer {\n    const len =\n      2 + // type\n      2 + // num_pong_bytes\n      2 + // byteslen\n      this.ignored.length\n\n    const br = new BufferWriter(Buffer.alloc(len))\n    br.writeUInt16BE(this.type)\n    br.writeUInt16BE(this.numPongBytes)\n    br.writeUInt16BE(this.ignored.length)\n    br.writeBytes(this.ignored)\n    return br.toBuffer()\n  }\n\n  /**\n   * triggersReply indicates if a pong message must send a reply.\n   * Ping messages than are smaller than 65532 must send a reply\n   * with the corresponding number of bytes. Above this value\n   * no reply is necessary.  Refer to BOLT #1.\n   */\n  public get triggersReply(): boolean {\n    return this.numPongBytes < PONG_BYTE_THRESHOLD\n  }\n}\n","import { Buffer } from 'buffer'\nimport { BufferReader, BufferWriter } from './buf'\nimport { MessageType } from '../types'\nimport { IWireMessage } from './IWireMessage'\n\nexport class PongMessage implements IWireMessage {\n  /**\n   * Deserializes a pong message from a Buffer into a PongMessage\n   * instance.\n   */\n  public static deserialize(payload: Buffer): PongMessage {\n    const instance = new PongMessage()\n\n    const reader = new BufferReader(payload)\n    reader.readUInt16BE() // read off type\n\n    const byteslen = reader.readUInt16BE()\n    instance.ignored = reader.readBytes(byteslen)\n    return instance\n  }\n\n  /**\n   * Message type = 19\n   */\n  public type: MessageType = MessageType.Pong\n\n  /**\n   * Should be set to zeros of length specified in a ping message's\n   * num_pong_bytes. Must not set ignored to sensitive data such as\n   * secrets or portions of initialized memory.\n   */\n  public ignored: Buffer\n\n  /**\n   * In order to allow for the existence of long-lived TCP\n   * connections, at times it may be required that both ends keep\n   * alive the TCP connection at the application level.\n   *\n   * The pong message is a reply to a ping message and must\n   * reply with the specify number of bytes when the num_pong_bytes\n   * value is less than 65532.\n   * for the number of pong bytes it expects to receive as\n   * a reply. The ignored bits should be set to 0.\n   */\n  constructor(numPongBytes = 0) {\n    this.ignored = Buffer.alloc(numPongBytes)\n  }\n\n  /**\n   * Serializes a PongMessage into a Buffer that can be\n   * streamed on the wire.\n   */\n  public serialize(): Buffer {\n    const len =\n      2 + // type\n      2 + // byteslen\n      +this.ignored.length\n\n    const writer = new BufferWriter(Buffer.alloc(len))\n    writer.writeUInt16BE(this.type)\n    writer.writeUInt16BE(this.ignored.length)\n    writer.writeBytes(this.ignored)\n    return writer.toBuffer()\n  }\n}\n","import { BufferReader } from './buf'\nimport { CommandoResponse, JsonRpcErrorResponse, MessageType } from '../types'\n\nexport class CommandoMessage {\n  /**\n   * Processes a buffer containing the message information. This method\n   * will capture the id of the commando response as well as the payload\n   */\n  public static deserialize(buffer: Buffer): CommandoMessage {\n    const instance = new CommandoMessage()\n    const reader = new BufferReader(buffer)\n\n    // read the type bytes\n    reader.readUInt16BE()\n\n    instance.id = reader.readBytes(8).toString('hex')\n    const json = reader.readBytes(buffer.byteLength - 26).toString()\n\n    try {\n      instance.response = JSON.parse(json)\n    } catch (error) {\n      instance.response = {\n        jsonrpc: '2.0',\n        id: null,\n        error: { code: 1, message: 'Could not parse json response' }\n      } as JsonRpcErrorResponse\n    }\n\n    return instance\n  }\n\n  public type: MessageType = MessageType.CommandoResponse\n  public id: string\n  public response: CommandoResponse\n}\n","import { BehaviorSubject, firstValueFrom, Observable, Subject } from 'rxjs'\nimport { filter, map, skip } from 'rxjs/operators'\nimport { Buffer } from 'buffer'\nimport { createRandomPrivateKey } from './crypto.js'\nimport { NoiseState } from './noise-state.js'\nimport { validateInit } from './validation.js'\nimport { deserialize } from './messages/MessageFactory.js'\nimport { IWireMessage } from './messages/IWireMessage.js'\nimport { BufferReader, BufferWriter } from './messages/buf.js'\nimport { CommandoMessage } from './messages/CommandoMessage.js'\nimport { PongMessage } from './messages/PongMessage.js'\nimport { PingMessage } from './messages/PingMessage.js'\n\nimport {\n  LnWebSocketOptions,\n  HANDSHAKE_STATE,\n  READ_STATE,\n  MessageType,\n  JsonRpcRequest,\n  JsonRpcSuccessResponse,\n  JsonRpcErrorResponse,\n  Logger,\n  CommandoRequest\n} from './types'\n\nconst DEFAULT_RECONNECT_ATTEMPTS = 5\n\nclass LnMessage {\n  /**The underlying Noise protocol. Can be used if you want to play around with the low level Lightning transport protocol*/\n  public noise: NoiseState\n  /**The public key of the node that Lnmessage is connected to*/\n  public remoteNodePublicKey: string\n  /**The public key Lnmessage uses when connecting to a remote node\n   * If you passed in a private key when initialising,\n   * this public key will be derived from it and can be used for persistent identity\n   * across session connections\n   */\n  public publicKey: string\n  /**The private key that was either passed in on init or generated automatically\n   * Reuse this when reconnecting for persistent id\n   */\n  public privateKey: string\n  /**The url that the WebSocket will connect to. It uses the wsProxy option if provided\n   * or otherwise will initiate a WebSocket connection directly to the node\n   */\n  public wsUrl: string\n  /**The WebSocket instance*/\n  public socket: WebSocket | null\n  /**Observable for subscribing to connection/disconnection*/\n  public connected$: BehaviorSubject<boolean>\n  /**Boolean indicating whether currently connecting or not*/\n  public connecting: boolean\n  /**Observable stream of decypted messages. This can be used to extend Lnmessage\n   * functionality so that it can handle other Lightning message types\n   */\n  public decryptedMsgs$: Observable<Buffer>\n  /**Obserable stream of all commando response messages*/\n  public commandoMsgs$: Observable<\n    (JsonRpcSuccessResponse | JsonRpcErrorResponse) & { reqId: string }\n  >\n  /**Node JS Buffer instance, useful if handling decrypted messages manually*/\n  public Buffer: BufferConstructor\n\n  private _ls: Buffer\n  private _es: Buffer\n  private _handshakeState: HANDSHAKE_STATE\n  private _readState: READ_STATE\n  private _decryptedMsgs$: Subject<Buffer>\n  private _commandoMsgs$: Subject<CommandoMessage>\n  private _partialCommandoMsgs: Record<string, Buffer>\n  private _attemptedReconnects: number\n  private _logger: Logger | void\n  private _attemptReconnect: boolean\n  private _messageBuffer: BufferReader\n  private _processingBuffer: boolean\n  private _l: number | null\n\n  constructor(options: LnWebSocketOptions) {\n    validateInit(options)\n\n    const { remoteNodePublicKey, wsProxy, privateKey, ip, port = 9735, logger } = options\n\n    this._ls = Buffer.from(privateKey || createRandomPrivateKey(), 'hex')\n    this._es = Buffer.from(createRandomPrivateKey(), 'hex')\n\n    this.noise = new NoiseState({\n      ls: this._ls,\n      es: this._es\n    })\n\n    this.remoteNodePublicKey = remoteNodePublicKey\n    this.publicKey = this.noise.lpk.toString('hex')\n    this.privateKey = this._ls.toString('hex')\n    this.wsUrl = wsProxy ? `${wsProxy}/${ip}:${port}` : `wss://${remoteNodePublicKey}@${ip}:${port}`\n    this.connected$ = new BehaviorSubject<boolean>(false)\n    this.connecting = false\n    this.Buffer = Buffer\n\n    this._handshakeState = HANDSHAKE_STATE.INITIATOR_INITIATING\n    this._decryptedMsgs$ = new Subject()\n    this.decryptedMsgs$ = this._decryptedMsgs$.asObservable()\n    this._commandoMsgs$ = new Subject()\n    this.commandoMsgs$ = this._commandoMsgs$\n      .asObservable()\n      .pipe(map(({ response, id }) => ({ ...response, reqId: id })))\n\n    this._partialCommandoMsgs = {}\n    this._attemptedReconnects = 0\n    this._logger = logger\n    this._readState = READ_STATE.READY_FOR_LEN\n    this._processingBuffer = false\n    this._l = null\n\n    this.decryptedMsgs$.subscribe((msg) => {\n      this.handleDecryptedMessage(msg)\n    })\n  }\n\n  async connect(attemptReconnect = true): Promise<boolean> {\n    if (this.connected$.getValue()) {\n      return true\n    }\n\n    this.connecting = true\n    this._log('info', `Initiating connection to node ${this.remoteNodePublicKey}`)\n    this._attemptReconnect = attemptReconnect\n    this._attemptedReconnects += 1\n    this.socket = new WebSocket(this.wsUrl)\n    this.socket.binaryType = 'arraybuffer'\n\n    this.socket.onopen = async () => {\n      this._log('info', 'WebSocket is connected')\n      this._log('info', 'Creating Act1 message')\n      const msg = await this.noise.initiatorAct1(Buffer.from(this.remoteNodePublicKey, 'hex'))\n\n      if (this.socket) {\n        this._log('info', 'Sending Act1 message')\n        this.socket.send(msg)\n        this._handshakeState = HANDSHAKE_STATE.AWAITING_RESPONDER_REPLY\n      }\n    }\n\n    this.socket.onclose = async () => {\n      this._log('error', 'WebSocket is closed')\n      this._log('info', `Attempted reconnects: ${this._attemptedReconnects}`)\n\n      this.connected$.next(false)\n\n      if (this._attemptReconnect && this._attemptedReconnects < DEFAULT_RECONNECT_ATTEMPTS) {\n        this.connecting = true\n        this._log('info', 'Waiting to reconnect')\n        await new Promise((resolve) => setTimeout(resolve, (this._attemptedReconnects || 1) * 1000))\n        this.connect()\n      }\n    }\n\n    this.socket.onerror = (err) => {\n      this._log('error', `WebSocket error: ${JSON.stringify(err)}`)\n    }\n\n    this.socket.onmessage = this.queueMessage.bind(this)\n\n    return firstValueFrom(this.connected$.pipe(skip(1)))\n  }\n\n  private queueMessage(event: MessageEvent) {\n    const { data } = event as { data: ArrayBuffer }\n    const message = Buffer.from(data)\n\n    const currentData =\n      this._messageBuffer && !this._messageBuffer.eof && this._messageBuffer.readBytes()\n\n    this._messageBuffer = new BufferReader(\n      currentData ? Buffer.concat([currentData, message]) : message\n    )\n\n    if (!this._processingBuffer) {\n      this._processingBuffer = true\n      this._processBuffer()\n    }\n  }\n\n  disconnect() {\n    this._log('info', 'Manually disconnecting from WebSocket')\n\n    // reset noise state\n    this.noise = new NoiseState({\n      ls: this._ls,\n      es: this._es\n    })\n\n    this._attemptReconnect = false\n    this.socket && this.socket.close()\n  }\n\n  private async _processBuffer() {\n    try {\n      // Loop while there was still data to process on the process\n      // buffer.\n      let readMore = true\n      do {\n        if (this._handshakeState !== HANDSHAKE_STATE.READY) {\n          switch (this._handshakeState) {\n            // Initiator received data before initialized\n            case HANDSHAKE_STATE.INITIATOR_INITIATING:\n              throw new Error('Received data before intialised')\n\n            // Initiator Act2\n            case HANDSHAKE_STATE.AWAITING_RESPONDER_REPLY:\n              readMore = await this._processResponderReply()\n              break\n          }\n        } else {\n          switch (this._readState) {\n            case READ_STATE.READY_FOR_LEN:\n              readMore = await this._processPacketLength()\n              break\n            case READ_STATE.READY_FOR_BODY:\n              readMore = await this._processPacketBody()\n              break\n            case READ_STATE.BLOCKED:\n              readMore = false\n              break\n            default:\n              throw new Error('Unknown read state')\n          }\n        }\n      } while (readMore)\n    } catch (err) {\n      // Terminate on failures as we won't be able to recovery\n      // since the noise state has rotated nonce and we won't\n      // be able to any more data without additional errors.\n      this.disconnect()\n    }\n\n    this._processingBuffer = false\n  }\n\n  private async _processResponderReply() {\n    // read 50 bytes\n    const data = this._messageBuffer.readBytes(50)\n\n    if (data.byteLength !== 50) {\n      throw new Error('Invalid message received from remote node')\n    }\n\n    // process reply\n    this._log('info', 'Validating message as part of Act2')\n    await this.noise.initiatorAct2(data)\n\n    // create final act of the handshake\n    this._log('info', 'Creating reply for Act3')\n    const reply = await this.noise.initiatorAct3()\n\n    if (this.socket) {\n      this._log('info', 'Sending reply for act3')\n      // send final handshake\n      this.socket.send(reply)\n\n      // transition\n      this._handshakeState = HANDSHAKE_STATE.READY\n    }\n\n    // return true to continue processing\n    return true\n  }\n\n  private async _processPacketLength() {\n    const LEN_CIPHER_BYTES = 2\n    const LEN_MAC_BYTES = 16\n\n    try {\n      // Try to read the length cipher bytes and the length MAC bytes\n      // If we cannot read the 18 bytes, the attempt to process the\n      // message will abort.\n      const lc = this._messageBuffer.readBytes(LEN_CIPHER_BYTES + LEN_MAC_BYTES)\n      if (!lc) return false\n\n      // Decrypt the length including the MAC\n      const l = await this.noise.decryptLength(lc)\n\n      // We need to store the value in a local variable in case\n      // we are unable to read the message body in its entirety.\n      // This allows us to skip the length read and prevents\n      // nonce issues since we've already decrypted the length.\n      this._l = l\n\n      // Transition state\n      this._readState = READ_STATE.READY_FOR_BODY\n\n      // return true to continue reading\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  private async _processPacketBody() {\n    const MESSAGE_MAC_BYTES = 16\n\n    if (!this._l) return false\n\n    try {\n      // With the length, we can attempt to read the message plus\n      // the MAC for the message. If we are unable to read because\n      // there is not enough data in the read buffer, we need to\n      // store l. We are not able to simply unshift it becuase we\n      // have already rotated the keys.\n      const c = this._messageBuffer.readBytes(this._l + MESSAGE_MAC_BYTES)\n      if (!c) return false\n\n      // Decrypt the full message cipher + MAC\n      const m = await this.noise.decryptMessage(c)\n\n      // Now that we've read the message, we can remove the\n      // cached length before we transition states\n      this._l = null\n\n      // Push the message onto the read buffer for the consumer to\n      // read. We are mindful of slow reads by the consumer and\n      // will respect backpressure signals.\n      this._decryptedMsgs$.next(m)\n      this._readState = READ_STATE.READY_FOR_LEN\n\n      return true\n    } catch (err) {\n      return false\n    }\n  }\n\n  async handleDecryptedMessage(decrypted: Buffer) {\n    try {\n      const reader = new BufferReader(decrypted)\n      const type = reader.readUInt16BE()\n      const [typeName] = Object.entries(MessageType).find(([name, val]) => val === type) || []\n      const requestId = reader.readBytes(8).toString('hex')\n      const message = reader.readBytes()\n\n      this._log('info', `Message type is: ${typeName || 'unknown'}`)\n\n      if (type === MessageType.CommandoResponseContinues) {\n        this._log(\n          'info',\n          'Received a partial commando message, caching it to join with other parts'\n        )\n\n        this._partialCommandoMsgs[requestId] = this._partialCommandoMsgs[requestId]\n          ? Buffer.concat([\n              this._partialCommandoMsgs[requestId],\n              message.subarray(0, message.byteLength - 16)\n            ])\n          : decrypted.subarray(0, decrypted.length - 16)\n\n        return\n      }\n\n      if (type === MessageType.CommandoResponse && this._partialCommandoMsgs[requestId]) {\n        this._log(\n          'info',\n          'Received a final commando msg and we have a partial message to join it to. Joining now'\n        )\n\n        // join commando msg chunks\n        decrypted = Buffer.concat([this._partialCommandoMsgs[requestId], message])\n        delete this._partialCommandoMsgs[requestId]\n      }\n\n      // deserialise\n      this._log('info', 'Deserialising payload')\n      const payload = deserialize(decrypted)\n\n      switch (payload.type) {\n        case MessageType.Init: {\n          this._log('info', 'Constructing Init message reply')\n          const reply = await this.noise.encryptMessage((payload as IWireMessage).serialize())\n\n          if (this.socket) {\n            this._log('info', 'Sending Init message reply')\n            this.socket.send(reply)\n            this._log('info', 'Connected and ready to send messages!')\n            this.connected$.next(true)\n            this.connecting = false\n            this._attemptedReconnects = 0\n          }\n\n          break\n        }\n\n        case MessageType.Ping: {\n          this._log('info', 'Received a Ping message')\n          this._log('info', 'Creating a Pong message')\n          const pongMessage = new PongMessage((payload as PingMessage).numPongBytes).serialize()\n          const pong = await this.noise.encryptMessage(pongMessage)\n\n          if (this.socket) {\n            this._log('info', 'Sending a Pong message')\n            this.socket.send(pong)\n          }\n\n          break\n        }\n\n        case MessageType.CommandoResponse: {\n          this._commandoMsgs$.next(payload as CommandoMessage)\n        }\n\n        // ignore all other messages\n      }\n    } catch (error) {\n      this._log('error', `Error handling incoming message: ${(error as Error).message}`)\n    }\n  }\n\n  async commando({\n    method,\n    params = [],\n    rune,\n    reqId\n  }: CommandoRequest): Promise<JsonRpcSuccessResponse['result']> {\n    this._log('info', `Commando request method: ${method} params: ${JSON.stringify(params)}`)\n\n    // not connected and not initiating a connection currently\n    if (!this.connected$.getValue() && !this.connecting) {\n      this._log('info', 'No socket connection, so creating one now')\n      await this.connect()\n    } else {\n      this._log('info', 'Ensuring we have a connection before making request')\n      // ensure that we are connected before making any requests\n      await firstValueFrom(this.connected$.pipe(filter((connected) => connected === true)))\n    }\n\n    const writer = new BufferWriter()\n\n    if (!reqId) {\n      // create random id to match request with response\n      const idBytes = Buffer.allocUnsafe(8)\n      const id = window.crypto.getRandomValues(idBytes)\n      reqId = id.toString('hex')\n    }\n\n    // write the type\n    writer.writeUInt16BE(MessageType.CommandoRequest)\n\n    // write the id\n    writer.writeBytes(Buffer.from(reqId, 'hex'))\n\n    // write the request\n    writer.writeBytes(\n      Buffer.from(\n        JSON.stringify({\n          rune,\n          method,\n          params\n        })\n      )\n    )\n\n    this._log('info', 'Creating message to send')\n    const message = await this.noise.encryptMessage(writer.toBuffer())\n\n    if (this.socket) {\n      this._log('info', 'Sending commando message')\n      this.socket.send(message)\n\n      this._log('info', 'Message sent and awaiting response')\n      const { response } = await firstValueFrom(\n        this._commandoMsgs$.pipe(filter((commandoMsg) => commandoMsg.id === reqId))\n      )\n\n      const { result } = response as JsonRpcSuccessResponse\n      const { error } = response as JsonRpcErrorResponse\n      this._log(\n        'info',\n        result ? 'Successful response received' : `Error response received: ${error.message}`\n      )\n\n      if (error) throw error\n\n      return result\n    } else {\n      throw new Error('No socket initialised and connected')\n    }\n  }\n\n  _log(level: keyof Logger, msg: string) {\n    if (this._logger && this._logger[level]) {\n      this._logger[level](`[${level.toUpperCase()} - ${new Date().toLocaleTimeString()}]: ${msg}`)\n    }\n  }\n}\n\nexport default LnMessage\n","import { validPrivateKey, validPublicKey } from './crypto.js'\nimport { LnWebSocketOptions, Logger } from './types'\n\nexport function validateInit(options: LnWebSocketOptions): void {\n  const { remoteNodePublicKey, wsProxy, privateKey, ip, port, logger } = options\n\n  if (!remoteNodePublicKey || !validPublicKey(remoteNodePublicKey)) {\n    throw new Error(`${remoteNodePublicKey} is not a valid public key`)\n  }\n\n  const ipRegex = /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)(\\.(?!$)|$)){4}$/\n\n  if (!ip || !ip.match(ipRegex)) {\n    throw new Error(`${ip} is not a valid IP address`)\n  }\n\n  if (!port || port < 1 || port > 65535) {\n    throw new Error(`${port} is not a valid port number`)\n  }\n\n  if (wsProxy) {\n    const errMsg = `${wsProxy} is not a valid url`\n    try {\n      const url = new URL(wsProxy)\n      if (url.protocol !== 'wss:' && url.protocol !== 'ws:') {\n        throw new Error(errMsg)\n      }\n    } catch (err) {\n      throw new Error(errMsg)\n    }\n  }\n\n  if (privateKey && !validPrivateKey(privateKey)) {\n    throw new Error(`${privateKey} is not a valid private key`)\n  }\n\n  if (logger) {\n    if (typeof logger !== 'object') {\n      throw new Error('Logger must be of type object')\n    }\n\n    const validLevels = ['info', 'warn', 'error']\n\n    Object.entries(logger).forEach(([level, handler]) => {\n      if (!validLevels.includes(level)) {\n        throw new Error(`Invalid logger level: ${level}`)\n      }\n\n      if (typeof handler !== 'function') {\n        throw new Error(`Logger for level: ${level} is not a function`)\n      }\n    })\n  }\n}\n","import { IWireMessage } from './IWireMessage.js'\nimport { InitMessage } from './InitMessage.js'\nimport { PingMessage } from './PingMessage.js'\nimport { PongMessage } from './PongMessage.js'\nimport { CommandoMessage } from './CommandoMessage.js'\nimport { MessageType } from '../types'\n\nexport function deserialize(buffer: Buffer): IWireMessage | { type: number } {\n  const type = buffer.readUInt16BE(0)\n\n  switch (type) {\n    case MessageType.Init:\n      return InitMessage.deserialize(buffer)\n    case MessageType.Ping:\n      return PingMessage.deserialize(buffer)\n    case MessageType.Pong:\n      return PongMessage.deserialize(buffer)\n    case MessageType.CommandoResponse:\n    case MessageType.CommandoResponseContinues:\n      return CommandoMessage.deserialize(buffer)\n  }\n\n  return { type }\n}\n"],"names":["ROTATE","v","c","Buffer","from","Chacha20","constructor","key","nonce","this","input","cachePos","buffer","output","constants","readUInt32LE","quarterRound","a","b","d","x","makeBlock","start","i","writeUInt32LE","Error","getBytes","len","dpos","dst","cacheLen","copy","Poly1305","leftover","r","h","pad","finished","Uint16Array","t","readUInt16LE","blocks","m","mpos","bytes","hibit","j","update","length","want","finish","mac","g","mask","f","writeUInt16LE","Cipher","iv","decrypt","alen","clen","chacha","poly","tag","_decrypt","_hasData","setAAD","aad","padding","padAmount","fill","data","inputEnc","outputEnc","_update","outData","toString","final","_final","chunk","lens","out","Math","min","xorTest","getAuthTag","setAuthTag","rem","ecdh","pubkey","privkey","secp256k1","hmacHash","words","CryptoJS","HmacSHA256","enc","Hex","parse","stringify","async","sha256","window","crypto","subtle","digest","res","hkdf","ikm","salt","alloc","info","prk","n","ceil","byteLength","tp","bi","push","concat","slice","subarray","privKey","compressed","publicKeyCreate","ccpEncrypt","k","ad","plaintext","cipher","ccpDecrypt","ciphertext","decipher","createRandomPrivateKey","allocUnsafe","getRandomValues","validPrivateKey","privateKey","privateKeyVerify","NoiseState","ls","es","protocolName","prologue","lpk","epk","rpk","repk","ck","rk","sk","sn","rn","tempK1","tempK2","tempK3","getPublicKey","_initialize","re","rs","l","writeUInt16BE","lc","_incrementSendingNonce","_rotateSendingKeys","_incrementRecievingNonce","_rotateRecievingKeys","readUInt16BE","newValue","result","BufferReader","static","num","BigInt","_buffer","_position","_lastReadBytes","position","val","eof","lastReadBytes","readUInt8","_readStandard","name","readUInt32BE","readUInt64BE","readBytes","readUInt64LE","reverse","readVarUint","size","readBigSize","RangeError","peakBytes","readTUInt16","readUIntBE","_assertMinimalTUInt","readTUInt32","readTUInt64","hex","fn","padStart","BufferWriter","_fixed","toBuffer","writeUInt8","_writeStandard","writeUInt32BE","writeUInt64LE","value","buf","writeBytes","writeUInt64BE","_expand","writeVarInt","Number","writeBigSize","writeTUInt16","writeUIntBE","writeTUInt32","writeTUInt64","valString","needed","required","newLen","log2","newBuf","BitField","isSet","bit","set","unset","toggle","flags","bits","msb","and","bitfield","or","xor","toBigInt","toNumber","bigintToBuffer","calcBytes","bigintutil","READ_STATE","MessageType","HANDSHAKE_STATE","InitMessage","type","Init","features","chainHashes","instance","reader","gflen","fromBuffer","lf","lflen","gf","readTlvs","handler","lastType","valueReader","isEven","wasHandled","error","chainHash","serialize","writer","PingMessage","Ping","numPongBytes","ignored","payload","cursor","bytesLength","br","triggersReply","PongMessage","byteslen","Pong","CommandoMessage","CommandoResponse","id","response","json","JSON","jsonrpc","code","message","LnMessage","options","noise","remoteNodePublicKey","publicKey","wsUrl","socket","connected$","connecting","decryptedMsgs$","commandoMsgs$","_ls","_es","_handshakeState","_readState","_decryptedMsgs$","_commandoMsgs$","_partialCommandoMsgs","_attemptedReconnects","_logger","_attemptReconnect","_messageBuffer","_processingBuffer","_l","validateInit","wsProxy","ip","port","logger","publicKeyVerify","match","errMsg","url","URL","protocol","err","validLevels","Object","entries","forEach","level","includes","BehaviorSubject","INITIATOR_INITIATING","Subject","asObservable","pipe","map","reqId","READY_FOR_LEN","subscribe","msg","handleDecryptedMessage","attemptReconnect","_this","getValue","_log","WebSocket","binaryType","onopen","initiatorAct1","send","AWAITING_RESPONDER_REPLY","onclose","next","Promise","resolve","setTimeout","connect","onerror","onmessage","queueMessage","bind","firstValueFrom","skip","event","currentData","_processBuffer","disconnect","close","readMore","READY","_processResponderReply","_processPacketLength","READY_FOR_BODY","_processPacketBody","BLOCKED","initiatorAct2","reply","initiatorAct3","LEN_CIPHER_BYTES","decryptLength","decryptMessage","decrypted","typeName","find","requestId","CommandoResponseContinues","deserialize","encryptMessage","pongMessage","pong","method","params","rune","filter","connected","idBytes","CommandoRequest","commandoMsg","toUpperCase","Date","toLocaleTimeString"],"mappings":"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"}